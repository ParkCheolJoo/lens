<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Î†åÏ¶à ÏãúÎÆ¨Î†àÏù¥ÌÑ∞</title>
    
    <!-- Ìè∞Ìä∏ Î∞è ÎùºÏù¥Î∏åÎü¨Î¶¨ -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Noto Sans KR', sans-serif; background: #050505; color: white; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* UI Ìå®ÎÑê Ïä§ÌÉÄÏùº */
        .ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(20, 20, 20, 0.9);
            padding: 15px;
            border-radius: 12px;
            width: 260px;
            max-height: 90vh;
            overflow-y: auto;
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255,255,255,0.15);
            user-select: none;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            z-index: 50;
        }
        
        /* Ïä§ÌÅ¨Î°§Î∞î Ïª§Ïä§ÌÖÄ */
        .ui-panel::-webkit-scrollbar { width: 6px; }
        .ui-panel::-webkit-scrollbar-track { background: #222; }
        .ui-panel::-webkit-scrollbar-thumb { background: #444; border-radius: 3px; }
        
        /* Î∑∞ ÎùºÎ≤® Ïä§ÌÉÄÏùº */
        .view-label {
            position: absolute;
            padding: 6px 12px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(74, 222, 128, 0.3);
            border-radius: 6px;
            font-size: 14px;
            font-weight: bold;
            pointer-events: none;
            color: #4ade80;
            z-index: 20;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        #label-main { top: 20px; right: 20px; }
        #label-eye { bottom: 20px; right: 20px; }
        
        /* Ïä¨ÎùºÏù¥Îçî Ïä§ÌÉÄÏùº */
        .slider-group { margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid #333; }
        .slider-label { display: flex; justify-content: space-between; margin-bottom: 4px; font-size: 0.8em; color: #ccc; }
        
        input[type=range] { 
            width: 100%; cursor: pointer; accent-color: #4ade80; 
            height: 4px; background: #444; border-radius: 2px;
            appearance: none;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px; height: 14px; background: #4ade80; border-radius: 50%;
        }

        /* Ï≤¥ÌÅ¨Î∞ïÏä§ Ïä§ÌÉÄÏùº */
        input[type=checkbox] {
            accent-color: #4ade80;
            cursor: pointer;
            width: 14px;
            height: 14px;
        }

        /* ÏÑ†ÌÉù Î≤ÑÌäº Ïä§ÌÉÄÏùº */
        .selector-row {
            display: flex;
            background: #333;
            border-radius: 8px;
            padding: 4px;
            margin-bottom: 12px;
            gap: 4px;
        }
        .selector-opt {
            flex: 1;
            text-align: center;
            padding: 6px 2px;
            cursor: pointer;
            border-radius: 6px;
            font-weight: bold;
            font-size: 0.75rem;
            transition: all 0.2s;
            color: #888;
        }
        .selector-opt.active {
            background: #4ade80;
            color: #000;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .legend { margin-top: 10px; font-size: 0.8em; color: #aaa; }
        .legend-item { display: flex; align-items: center; margin-bottom: 4px; }
        .color-box { width: 12px; height: 12px; margin-right: 8px; border-radius: 2px; }
        
        /* ÌôîÎ©¥ Î∂ÑÌï† ÏÑ† */
        #divider {
            position: absolute;
            left: 0;
            width: 100%;
            height: 4px;
            background: #222;
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            z-index: 10;
            cursor: ns-resize;
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>
    <div id="divider"></div>

    <div id="label-main" class="view-label">3D ÏûÖÏ≤¥ Í¥ëÏÑ† Ï∂îÏ†Å (Top View)</div>
    <div id="label-eye" class="view-label">ÎààÏúºÎ°ú Î≥∏ Î™®Ïäµ (Observer View)</div>

    <div class="ui-panel">
        <h2 class="text-lg font-bold mb-3 text-green-400 border-b border-gray-600 pb-2">3D Î†åÏ¶à ÏãúÎÆ¨Î†àÏù¥ÌÑ∞</h2>
        
        <!-- Lens Selector -->
        <div class="font-bold text-xs text-white mb-1">Î†åÏ¶à Ï¢ÖÎ•ò (Lens Type)</div>
        <div class="selector-row">
            <div id="btn-convex" class="selector-opt active">Î≥ºÎ°ù (Convex)</div>
            <div id="btn-concave" class="selector-opt">Ïò§Î™© (Concave)</div>
        </div>

        <!-- Object Selector -->
        <div class="font-bold text-xs text-white mb-1">Î¨ºÏ≤¥ Î™®Ïñë (Object Shape)</div>
        <div class="selector-row">
            <div id="btn-obj-arrow" class="selector-opt active">ÌôîÏÇ¥Ìëú (Arrow)</div>
            <div id="btn-obj-knot" class="selector-opt">3D Îß§Îì≠ (Knot)</div>
        </div>

        <div class="slider-group">
            <div class="font-bold text-xs text-white mb-2">‚öôÔ∏è Î†åÏ¶à ÏÑ§Ï†ï (Lens)</div>
            <div class="slider-label">
                <span>Ï¥àÏ†ê Í±∞Î¶¨ (Focal Length)</span>
                <span id="val-focal" class="font-mono text-green-300">15.0</span>
            </div>
            <input type="range" id="input-focal" min="10" max="40" step="0.5" value="15">
            <div id="text-lens-desc" class="text-xs text-gray-500 mt-1">ÏûëÏùÑÏàòÎ°ù Î†åÏ¶àÍ∞Ä ÎëêÍ∫ºÏõåÏßê (Í∞ïÌïú Íµ¥Ï†à)</div>
            
            <div class="slider-label mt-2">
                <span>Î¨ºÏ≤¥ ÌÅ¨Í∏∞ (Size)</span>
                <span id="val-height" class="font-mono text-green-300">5.0</span>
            </div>
            <input type="range" id="input-height" min="2" max="10" step="0.5" value="5">
        </div>

        <div class="slider-group">
            <div class="font-bold text-sm text-white mb-2">üïπÔ∏è ÏúÑÏπò Ï†úÏñ¥ (Position)</div>
            
            <div class="slider-label">
                <span>Í±∞Î¶¨ (Distance X)</span>
                <span id="val-dist" class="font-mono text-green-300">30.0</span>
            </div>
            <input type="range" id="input-dist" min="5" max="60" step="0.5" value="30">
            
            <div class="slider-label mt-2">
                <span>ÎÜíÏù¥ (Vertical Y)</span>
                <span id="val-offset-y" class="font-mono text-green-300">0.0</span>
            </div>
            <input type="range" id="input-offset-y" min="-15" max="15" step="0.5" value="0">

            <div class="slider-label mt-2">
                <span>Ï¢åÏö∞ (Horizontal Z)</span>
                <span id="val-offset-z" class="font-mono text-green-300">0.0</span>
            </div>
            <input type="range" id="input-offset-z" min="-15" max="15" step="0.5" value="0">
        </div>

        <!-- Rotation Control with Legend -->
        <div class="slider-group">
            <div class="flex justify-between items-center mb-2">
                <div class="font-bold text-sm text-white">üîÑ ÌöåÏ†Ñ (Rotation)</div>
                <!-- Checkbox to toggle axes -->
                <label class="flex items-center space-x-1 cursor-pointer select-none">
                    <!-- [FIX] Removed 'checked' attribute so it starts unchecked -->
                    <input type="checkbox" id="check-show-axes">
                    <span class="text-xs text-gray-300 hover:text-white">Ï∂ï Î≥¥Í∏∞</span>
                </label>
            </div>
            
            <div class="text-[10px] text-gray-400 font-mono text-right mb-2">
                <span class="text-red-400 mr-1">R:X</span> 
                <span class="text-green-400 mr-1">G:Y</span> 
                <span class="text-blue-400">B:Z</span>
            </div>
            
            <div class="slider-label">
                <span class="text-red-300">XÏ∂ï (Pitch)</span>
                <span id="val-rot-x" class="font-mono text-blue-300">0¬∞</span>
            </div>
            <input type="range" id="input-rot-x" min="-360" max="360" step="5" value="0">

            <div class="slider-label mt-2">
                <span class="text-green-300">YÏ∂ï (Yaw)</span>
                <span id="val-rot-y" class="font-mono text-blue-300">0¬∞</span>
            </div>
            <input type="range" id="input-rot-y" min="-360" max="360" step="5" value="0">

            <div class="slider-label mt-2">
                <span class="text-blue-300">ZÏ∂ï (Roll)</span>
                <span id="val-rot-z" class="font-mono text-blue-300">0¬∞</span>
            </div>
            <input type="range" id="input-rot-z" min="-360" max="360" step="5" value="0">
        </div>

        <div class="p-3 bg-gray-800 rounded border border-gray-700 mb-2">
            <div class="flex justify-between mb-1 text-sm">
                <span class="text-gray-400">ÏÉÅÏùò Ï¢ÖÎ•ò:</span>
                <span id="info-type" class="font-bold text-white">--</span>
            </div>
            <div class="flex justify-between mb-1 text-sm">
                <span class="text-gray-400">Î∞∞Ïú®(Ï§ëÏã¨):</span>
                <span id="info-mag" class="font-bold text-white">--</span>
            </div>
        </div>

        <div class="legend">
            <div class="legend-item"><div class="color-box bg-red-500"></div>Î¨ºÏ≤¥ (Object)</div>
            <div class="legend-item"><div class="color-box bg-blue-400"></div>ÏÉÅ (Image)</div>
            <div class="legend-item"><div class="color-box bg-yellow-300"></div>Í¥ëÏÑ† (4ÏÉâ Íµ¨Î∂Ñ)</div>
        </div>
    </div>

    <!-- Î°úÏßÅ Ïä§ÌÅ¨Î¶ΩÌä∏ -->
    <script>
    // --- 1. Scene Setup ---
    const container = document.getElementById('canvas-container');
    const divider = document.getElementById('divider');
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false, stencil: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.autoClear = false; 
    container.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);
    scene.fog = new THREE.Fog(0x111111, 80, 250);

    // --- Cameras ---
    const cameraTop = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    cameraTop.position.set(40, 30, 60);
    cameraTop.lookAt(0, 0, 0);

    const cameraEye = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 1000);
    cameraEye.position.set(66, 0, 0); 
    cameraEye.lookAt(0, 0, 0);
    
    const controls = new THREE.OrbitControls(cameraTop, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    // --- 2. Lighting ---
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
    ambientLight.layers.enableAll(); 
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(20, 50, 30);
    dirLight.layers.enableAll();
    scene.add(dirLight);
    
    const rimLight = new THREE.PointLight(0x44aaff, 0.5);
    rimLight.position.set(-20, 0, -20);
    rimLight.layers.enableAll();
    scene.add(rimLight);

    // --- Helpers ---
    const gridHelper = new THREE.GridHelper(200, 40, 0x333333, 0x1a1a1a);
    gridHelper.position.y = -20;
    gridHelper.layers.set(0);
    scene.add(gridHelper);

    const axisGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-200,0,0), new THREE.Vector3(200,0,0)]);
    const axisMat = new THREE.LineBasicMaterial({ color: 0x555555, transparent: true, opacity: 0.5 });
    const axisLine = new THREE.Line(axisGeo, axisMat);
    axisLine.layers.enableAll();
    scene.add(axisLine);

    // --- 3. Objects ---
    const lensMat = new THREE.MeshPhysicalMaterial({
        color: 0xaaccff, transmission: 0.95, opacity: 1, metalness: 0, roughness: 0,
        ior: 1.5, thickness: 3.0, clearcoat: 1.0, side: THREE.DoubleSide
    });
    
    const lensRimMat = new THREE.MeshStandardMaterial({ color: 0x445566, roughness: 0.4, metalness: 0.8 });
    const objectMat = new THREE.MeshStandardMaterial({ color: 0xff3333, emissive: 0x440000 });
    const imageMat = new THREE.MeshStandardMaterial({ color: 0x3388ff, emissive: 0x001144, transparent: true, opacity: 0.9 });
    
    const rayMat = new THREE.LineBasicMaterial({ color: 0xffdd00, linewidth: 1, transparent: true, opacity: 0.6 });
    const virtualRayMat = new THREE.LineDashedMaterial({ color: 0xaaaaaa, dashSize: 2, gapSize: 1, scale: 1, transparent: true, opacity: 0.4 });

    const rayColors = [0xff4444, 0x44ff44, 0x44ffff, 0xff44ff];
    const rayMaterials = rayColors.map(c => new THREE.LineBasicMaterial({ color: c, linewidth: 1, transparent: true, opacity: 0.7 }));
    const virtualRayMaterials = rayColors.map(c => new THREE.LineDashedMaterial({ color: c, dashSize: 2, gapSize: 1, scale: 1, transparent: true, opacity: 0.4 }));

    // [New] Elegant World Axis Gizmo Creator (Static, HUD Style)
    function createNiceAxes(size) {
        const group = new THREE.Group();
        const axisRadius = 0.05 * size; 
        const axisLen = size;
        const coneHeight = 0.2 * size;
        const coneRadius = 0.12 * size;

        // Use BasicMaterial with transparent/opacity for Hologram effect
        // depthTest: false to ensure it renders on top of the object
        const commonMat = { depthTest: false, transparent: true, opacity: 0.7, side: THREE.DoubleSide };
        
        const matR = new THREE.MeshBasicMaterial({ ...commonMat, color: 0xff4444 }); // X (Red)
        const matG = new THREE.MeshBasicMaterial({ ...commonMat, color: 0x44ff44 }); // Y (Green)
        const matB = new THREE.MeshBasicMaterial({ ...commonMat, color: 0x4488ff }); // Z (Blue)
        const matW = new THREE.MeshBasicMaterial({ ...commonMat, color: 0xffffff, opacity: 0.5 }); // Center

        // To control render order (ensure it draws last, on top of object)
        const setRenderOrder = (mesh) => { mesh.renderOrder = 999; };

        // Center Sphere
        const sphere = new THREE.Mesh(new THREE.SphereGeometry(axisRadius * 2.0), matW);
        setRenderOrder(sphere);
        group.add(sphere);

        // X Axis (Red) - Points +X
        const xGeo = new THREE.CylinderGeometry(axisRadius, axisRadius, axisLen, 8);
        xGeo.translate(0, axisLen/2, 0);
        xGeo.rotateZ(-Math.PI/2);
        const xMesh = new THREE.Mesh(xGeo, matR);
        setRenderOrder(xMesh);
        group.add(xMesh);
        
        const xCone = new THREE.Mesh(new THREE.ConeGeometry(coneRadius, coneHeight, 16), matR);
        xCone.position.set(axisLen, 0, 0);
        xCone.rotation.z = -Math.PI/2;
        setRenderOrder(xCone);
        group.add(xCone);

        // Y Axis (Green) - Points +Y
        const yGeo = new THREE.CylinderGeometry(axisRadius, axisRadius, axisLen, 8);
        yGeo.translate(0, axisLen/2, 0);
        const yMesh = new THREE.Mesh(yGeo, matG);
        setRenderOrder(yMesh);
        group.add(yMesh);
        
        const yCone = new THREE.Mesh(new THREE.ConeGeometry(coneRadius, coneHeight, 16), matG);
        yCone.position.set(0, axisLen, 0);
        setRenderOrder(yCone);
        group.add(yCone);

        // Z Axis (Blue) - Points +Z
        const zGeo = new THREE.CylinderGeometry(axisRadius, axisRadius, axisLen, 8);
        zGeo.translate(0, axisLen/2, 0);
        zGeo.rotateX(Math.PI/2);
        const zMesh = new THREE.Mesh(zGeo, matB);
        setRenderOrder(zMesh);
        group.add(zMesh);
        
        const zCone = new THREE.Mesh(new THREE.ConeGeometry(coneRadius, coneHeight, 16), matB);
        zCone.position.set(0, 0, axisLen);
        zCone.rotation.x = Math.PI/2;
        setRenderOrder(zCone);
        group.add(zCone);

        return group;
    }

    // Add Global Gizmo to Scene (Independent from Objects)
    // Size 4.0 for clear visibility
    const refGizmo = createNiceAxes(4.0);
    refGizmo.layers.set(0); 
    scene.add(refGizmo);

    function create3DArrow(material, name) {
        const group = new THREE.Group();
        const stemGeo = new THREE.CylinderGeometry(0.3, 0.3, 1, 16);
        stemGeo.translate(0, 0.5, 0); 
        const stem = new THREE.Mesh(stemGeo, material);
        group.add(stem);
        const headGeo = new THREE.ConeGeometry(0.8, 1.2, 16);
        headGeo.translate(0, 0.6, 0); 
        const head = new THREE.Mesh(headGeo, material);
        head.position.y = 1; 
        group.add(head);
        
        group.name = name;
        return group;
    }

    function create3DKnot(material, name) {
        const geo = new THREE.TorusKnotGeometry(1, 0.3, 64, 16);
        const mesh = new THREE.Mesh(geo, material);
        const group = new THREE.Group();
        group.add(mesh);

        group.name = name;
        return group;
    }

    // --- LENS GEOMETRIES ---
    const lensGroup = new THREE.Group();
    scene.add(lensGroup);

    const convexGeo = new THREE.SphereGeometry(14, 64, 32);
    const convexMesh = new THREE.Mesh(convexGeo, lensMat);
    lensGroup.add(convexMesh);

    const concaveProfile = [];
    const stepsLathe = 20;
    const R_lens = 14;
    const T_center = 1.0; 
    const T_edge = 5.0;   
    for (let i = 0; i <= stepsLathe; i++) {
        const r = (i / stepsLathe) * R_lens; 
        const halfThick = (T_center + (T_edge - T_center) * (r/R_lens)**2) / 2;
        concaveProfile.push(new THREE.Vector2(r, halfThick));
    }
    for (let i = stepsLathe; i >= 0; i--) {
        const r = (i / stepsLathe) * R_lens;
        const halfThick = (T_center + (T_edge - T_center) * (r/R_lens)**2) / 2;
        concaveProfile.push(new THREE.Vector2(r, -halfThick));
    }
    const concaveGeo = new THREE.LatheGeometry(concaveProfile, 32);
    const concaveMesh = new THREE.Mesh(concaveGeo, lensMat);
    concaveMesh.rotation.z = -Math.PI / 2;
    concaveMesh.visible = false;
    lensGroup.add(concaveMesh);

    const rimGeo = new THREE.TorusGeometry(14, 0.3, 32, 100);
    const rimMesh = new THREE.Mesh(rimGeo, lensRimMat);
    rimMesh.rotation.y = Math.PI / 2;
    lensGroup.add(rimMesh);
    lensGroup.traverse(c => { c.layers.enableAll(); });

    // --- OBJECTS ---
    const objGroup = new THREE.Group();
    scene.add(objGroup);

    const objArrow = create3DArrow(objectMat, "ObjectArrow");
    const baseSphere = new THREE.Mesh(new THREE.SphereGeometry(0.4), objectMat);
    objArrow.add(baseSphere);
    objGroup.add(objArrow);

    const imgArrow = create3DArrow(imageMat, "ImageArrow");
    const imgBaseSphere = new THREE.Mesh(new THREE.SphereGeometry(0.4), imageMat);
    imgArrow.add(imgBaseSphere);
    objGroup.add(imgArrow);

    const objKnot = create3DKnot(objectMat, "ObjectKnot");
    objGroup.add(objKnot);
    const imgKnot = create3DKnot(imageMat, "ImageKnot");
    objGroup.add(imgKnot);
    
    objKnot.visible = false;
    imgKnot.visible = false;

    // FOCAL POINTS
    const focalGeo = new THREE.SphereGeometry(0.3, 16, 16);
    const focalMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
    const fPoint1 = new THREE.Mesh(focalGeo, focalMat);
    const fPoint2 = new THREE.Mesh(focalGeo, focalMat);
    fPoint1.layers.set(0);
    fPoint2.layers.set(0);
    scene.add(fPoint1);
    scene.add(fPoint2);

    const raysGroup = new THREE.Group();
    raysGroup.layers.set(0);
    scene.add(raysGroup);

    // --- 4. Logic & Simulation ---
    let currentLensType = 'convex';
    let currentObjType = 'arrow';

    const ui = {
        dist: document.getElementById('input-dist'),
        offsetY: document.getElementById('input-offset-y'),
        offsetZ: document.getElementById('input-offset-z'),
        focal: document.getElementById('input-focal'),
        height: document.getElementById('input-height'),
        rotX: document.getElementById('input-rot-x'),
        rotY: document.getElementById('input-rot-y'),
        rotZ: document.getElementById('input-rot-z'),
        valDist: document.getElementById('val-dist'),
        valOffsetY: document.getElementById('val-offset-y'),
        valOffsetZ: document.getElementById('val-offset-z'),
        valFocal: document.getElementById('val-focal'),
        valHeight: document.getElementById('val-height'),
        valRotX: document.getElementById('val-rot-x'),
        valRotY: document.getElementById('val-rot-y'),
        valRotZ: document.getElementById('val-rot-z'),
        infoType: document.getElementById('info-type'),
        infoMag: document.getElementById('info-mag'),
        btnConvex: document.getElementById('btn-convex'),
        btnConcave: document.getElementById('btn-concave'),
        btnObjArrow: document.getElementById('btn-obj-arrow'),
        btnObjKnot: document.getElementById('btn-obj-knot'),
        checkAxes: document.getElementById('check-show-axes'), // [New]
        descText: document.getElementById('text-lens-desc')
    };

    function setLensType(type) {
        currentLensType = type;
        if (type === 'convex') {
            ui.btnConvex.classList.add('active');
            ui.btnConcave.classList.remove('active');
            convexMesh.visible = true;
            concaveMesh.visible = false;
            ui.descText.textContent = "ÏûëÏùÑÏàòÎ°ù Î†åÏ¶àÍ∞Ä ÎëêÍ∫ºÏõåÏßê (Í∞ïÌïú Íµ¥Ï†à)";
        } else {
            ui.btnConvex.classList.remove('active');
            ui.btnConcave.classList.add('active');
            convexMesh.visible = false;
            concaveMesh.visible = true;
            ui.descText.textContent = "ÏûëÏùÑÏàòÎ°ù Í≥°Î•†Ïù¥ Ïã¨Ìï¥Ïßê (Í∞ïÌïú Î∞úÏÇ∞)";
        }
        updateSimulation();
    }
    
    function setObjType(type) {
        currentObjType = type;
        if (type === 'arrow') {
            ui.btnObjArrow.classList.add('active');
            ui.btnObjKnot.classList.remove('active');
            objArrow.visible = true;
            imgArrow.visible = true;
            objKnot.visible = false;
            imgKnot.visible = false;
        } else {
            ui.btnObjArrow.classList.remove('active');
            ui.btnObjKnot.classList.add('active');
            objArrow.visible = false;
            imgArrow.visible = false;
            objKnot.visible = true;
            imgKnot.visible = true;
        }
        updateSimulation();
    }

    ui.btnConvex.addEventListener('click', () => setLensType('convex'));
    ui.btnConcave.addEventListener('click', () => setLensType('concave'));
    ui.btnObjArrow.addEventListener('click', () => setObjType('arrow'));
    ui.btnObjKnot.addEventListener('click', () => setObjType('knot'));
    
    // [New] Toggle Listener
    ui.checkAxes.addEventListener('change', () => {
        refGizmo.visible = ui.checkAxes.checked;
    });

    // [New] Core Optical Calculation Function
    function computeImagePos(worldPoint, f) {
        // Optical Axis is X. Lens is at x=0.
        // Lens formula: 1/do + 1/di = 1/f
        // do = -x_obj (if object is left)
        
        const do_dist = -worldPoint.x;
        
        // Singularity check (close to focal point)
        if (Math.abs(do_dist - f) < 0.01) {
             return new THREE.Vector3(10000 * Math.sign(f), worldPoint.y * 100, worldPoint.z * 100); // Infinity
        }

        const di_dist = (f * do_dist) / (do_dist - f);
        const M = -di_dist / do_dist;
        
        // Resulting image point
        return new THREE.Vector3(di_dist, worldPoint.y * M, worldPoint.z * M);
    }

    function updateSimulation() {
        const do_val = parseFloat(ui.dist.value);
        let f_val_mag = parseFloat(ui.focal.value);
        let f_val = (currentLensType === 'convex') ? f_val_mag : -f_val_mag;
        const h_scale = parseFloat(ui.height.value);
        const off_y = parseFloat(ui.offsetY.value); 
        const off_z = parseFloat(ui.offsetZ.value);
        
        const rot_x_deg = parseFloat(ui.rotX.value);
        const rot_y_deg = parseFloat(ui.rotY.value);
        const rot_z_deg = parseFloat(ui.rotZ.value);
        const rad_x = THREE.MathUtils.degToRad(rot_x_deg);
        const rad_y = THREE.MathUtils.degToRad(rot_y_deg);
        const rad_z = THREE.MathUtils.degToRad(rot_z_deg);

        ui.valDist.textContent = do_val.toFixed(1);
        ui.valOffsetY.textContent = off_y.toFixed(1);
        ui.valOffsetZ.textContent = off_z.toFixed(1);
        ui.valFocal.textContent = f_val_mag.toFixed(1);
        ui.valHeight.textContent = h_scale.toFixed(1);
        ui.valRotX.textContent = rot_x_deg + "¬∞";
        ui.valRotY.textContent = rot_y_deg + "¬∞";
        ui.valRotZ.textContent = rot_z_deg + "¬∞";

        // Lens Shape
        if (currentLensType === 'convex') {
            const thicknessFactor = 3.0 / f_val_mag; 
            convexMesh.scale.set(thicknessFactor, 1, 1);
        } else {
            const scaleFactor = 20.0 / f_val_mag; 
            concaveMesh.scale.set(1, scaleFactor, 1); 
        }

        // Object Transform
        const objPos = new THREE.Vector3(-do_val, off_y, off_z);
        // [NOTE] Using ZYX order to facilitate typical object manipulation
        const objRotation = new THREE.Euler(rad_x, rad_y, rad_z, 'ZYX');
        
        const arrowScale = h_scale / 2.0; 
        const knotScale = h_scale / 2.5;

        // Apply to Objects
        if (currentObjType === 'arrow') {
            objArrow.position.copy(objPos);
            objArrow.scale.set(arrowScale, arrowScale, arrowScale);
            objArrow.rotation.copy(objRotation);
        } else {
            objKnot.position.copy(objPos);
            objKnot.scale.set(knotScale, knotScale, knotScale);
            objKnot.rotation.copy(objRotation);
        }

        // Update Global Reference Gizmo Position
        // [FIX] Gizmo follows object position but stays axis-aligned (Static Rotation)
        // [FIX] Using overlay material ensures visibility even inside object
        refGizmo.position.copy(objPos);
        refGizmo.rotation.set(0, 0, 0); // Always World Aligned
        // Apply Visibility based on checkbox
        refGizmo.visible = ui.checkAxes.checked;

        // Focal Points
        fPoint1.position.set(-f_val_mag, 0, 0);
        fPoint2.position.set(f_val_mag, 0, 0);

        // --- Optical Calculation for Center (for UI info) ---
        let center_di_val = 0;
        let center_magnification = 0;
        let isReal = true;
        let isParallel = false;

        // Simple calc for center just to get info state
        if (Math.abs(do_val) < 0.1) {
            isParallel = false;
            center_magnification = 1;
            ui.infoType.textContent = "Î†åÏ¶à Ï§ëÏã¨ (ÏùºÏπò)";
            ui.infoType.style.color = "#ffffff";
            isReal = false; 
        } 
        else if (currentLensType === 'convex' && Math.abs(do_val - f_val) < 0.1) {
            isParallel = true;
            ui.infoType.textContent = "Ï¥àÏ†ê ÏúÑ (ÏÉÅ ÏóÜÏùå)";
            ui.infoType.style.color = "#ffff00";
        } else {
            center_di_val = (f_val * do_val) / (do_val - f_val);
            center_magnification = -center_di_val / do_val; 

            if (center_di_val > 0) {
                isReal = true;
                ui.infoType.textContent = "Ïã§ÏÉÅ (ÎèÑÎ¶Ω)";
                ui.infoType.style.color = "#4ade80"; 
            } else {
                isReal = false;
                ui.infoType.textContent = "ÌóàÏÉÅ (Ï†ïÎ¶Ω)";
                ui.infoType.style.color = "#f87171"; 
            }
        }
        ui.infoMag.textContent = Math.abs(center_magnification).toFixed(2) + "Î∞∞";

        // --- Advanced Image Placement (Fitting) ---
        let targetImg = (currentObjType === 'arrow') ? imgArrow : imgKnot;
        
        targetImg.visible = !isParallel;
        if (!isReal) {
             targetImg.children.forEach(m => { if(m.material) m.material.opacity = 0.5; });
        } else {
             targetImg.children.forEach(m => { if(m.material) m.material.opacity = 1.0; });
        }

        if (!isParallel) {
            if (currentObjType === 'arrow') {
                // ... (Arrow Logic remains same) ...
                // 1. Calculate World Position of Object Base and Tip
                const objBaseLocal = new THREE.Vector3(0,0,0);
                const objTipLocal = new THREE.Vector3(0, 2.2 * arrowScale, 0); 

                // To World
                const objBaseWorld = objBaseLocal.clone().applyEuler(objRotation).add(objPos);
                const objTipWorld = objTipLocal.clone().applyEuler(objRotation).add(objPos);

                // 2. Compute Optical Image Positions
                const imgBaseWorld = computeImagePos(objBaseWorld, f_val);
                const imgTipWorld = computeImagePos(objTipWorld, f_val);

                // 3. Fit Image Mesh
                targetImg.position.copy(imgBaseWorld);

                const imgVector = new THREE.Vector3().subVectors(imgTipWorld, imgBaseWorld);
                const imgLength = imgVector.length();

                if (imgLength > 0.001) {
                    const dir = imgVector.clone().normalize();
                    targetImg.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), dir);
                }

                const thicknessScale = arrowScale * Math.abs(center_magnification);
                const geomHeight = 2.2; 
                targetImg.scale.set(thicknessScale, imgLength / geomHeight, thicknessScale);

            } else {
                // [FIX] Advanced Knot Fitting Logic
                const geomRadius = 1.3; 
                const r = geomRadius * knotScale; 
                
                // 1. Define 4 cardinal points in Local Space (matching ray sources)
                const ptTop = new THREE.Vector3(0, r, 0);
                const ptBot = new THREE.Vector3(0, -r, 0);
                const ptFront = new THREE.Vector3(0, 0, r);
                const ptBack = new THREE.Vector3(0, 0, -r);

                // 2. Transform to World Space (Apply Object Rotation & Position)
                const wTop = ptTop.clone().applyEuler(objRotation).add(objPos);
                const wBot = ptBot.clone().applyEuler(objRotation).add(objPos);
                const wFront = ptFront.clone().applyEuler(objRotation).add(objPos);
                const wBack = ptBack.clone().applyEuler(objRotation).add(objPos);

                // 3. Compute Image Positions for all 4 points
                const iTop = computeImagePos(wTop, f_val);
                const iBot = computeImagePos(wBot, f_val);
                const iFront = computeImagePos(wFront, f_val);
                const iBack = computeImagePos(wBack, f_val);
                
                // 4. Set Mesh Position (Use Image Center)
                const wCenter = new THREE.Vector3(0,0,0).applyEuler(objRotation).add(objPos);
                const iCenter = computeImagePos(wCenter, f_val);
                targetImg.position.copy(iCenter);

                // 5. Orientation Fitting
                // Calculate distorted vectors in image space
                const vY = new THREE.Vector3().subVectors(iTop, iBot);     // Vertical span
                const vZ = new THREE.Vector3().subVectors(iFront, iBack);  // Depth span

                // Construct a rotation matrix to align mesh Y to vY and mesh Z roughly to vZ
                const yAxis = vY.clone().normalize();
                let zAxis = vZ.clone().normalize();
                
                // Ensure axes are orthogonal (Gram-Schmidt-like process)
                // X = Y cross Z
                const xAxis = new THREE.Vector3().crossVectors(yAxis, zAxis).normalize();
                // Recalculate Z = X cross Y to ensure perfect orthogonality
                zAxis.crossVectors(xAxis, yAxis).normalize();

                const rotMatrix = new THREE.Matrix4().makeBasis(xAxis, yAxis, zAxis);
                targetImg.quaternion.setFromRotationMatrix(rotMatrix);

                // 6. Scale Fitting
                // Scale dimensions to match the distance between projected points
                // Base diameter is 2 * geomRadius
                const lenY = vY.length();
                const lenZ = vZ.length();
                
                // For X (Width), we use center magnification as we don't track Left/Right rays
                const scaleX = knotScale * Math.abs(center_magnification);
                
                targetImg.scale.set(
                    scaleX, 
                    lenY / (2 * geomRadius), 
                    lenZ / (2 * geomRadius)
                );
            }
        }

        // --- Multi-Ray Tracing ---
        // Ray Source Points
        let sourcePointsLocal = [];
        if (currentObjType === 'arrow') {
            const s = arrowScale;
            sourcePointsLocal.push(new THREE.Vector3(0, 2.2 * s, 0)); // Tip
        } else {
            // Knot: 4 cardinal points
            // IMPORTANT: The first point (index 0) MUST correspond to the 'Top' point used in geometry fitting above (Y+)
            // to ensure the visual ray matches the mesh distortion.
            const r = 1.3 * knotScale;
            sourcePointsLocal.push(new THREE.Vector3(0, r, 0));   // Top (Matches fitting logic)
            sourcePointsLocal.push(new THREE.Vector3(0, -r, 0));  // Bottom
            sourcePointsLocal.push(new THREE.Vector3(0, 0, r));   // Front
            sourcePointsLocal.push(new THREE.Vector3(0, 0, -r));  // Back
        }
        
        while(raysGroup.children.length > 0){ 
            const obj = raysGroup.children.pop();
            if(obj.geometry) obj.geometry.dispose();
            raysGroup.remove(obj); 
        }

        sourcePointsLocal.forEach((localPt, index) => {
            const rotatedLocalPt = localPt.clone().applyEuler(objRotation);
            const objTip = new THREE.Vector3().copy(rotatedLocalPt).add(objPos);
            
            let imgTip;
            if (isParallel) {
                imgTip = new THREE.Vector3(10000 * Math.sign(f_val), 0, 0);
            } else if (Math.abs(do_val) < 0.1) {
                imgTip = objTip.clone();
            } else {
                // [FIX] Use the EXACT optical formula for the Ray Target as well
                imgTip = computeImagePos(objTip, f_val);
            }
            
            const colorIndex = (currentObjType === 'arrow') ? -1 : index;
            draw3DRays(objTip, imgTip, f_val, isReal, isParallel, colorIndex);
        });
        
        updateLayers();
    }

    function draw3DRays(objTip, imgTip, f_val, isReal, isParallel, colorIndex) {
        let rMat, vMat;
        if (colorIndex === -1) {
            rMat = rayMat; 
            vMat = virtualRayMat;
        } else {
            rMat = rayMaterials[colorIndex % rayMaterials.length];
            vMat = virtualRayMaterials[colorIndex % virtualRayMaterials.length];
        }

        const lensHit1 = new THREE.Vector3(0, objTip.y, objTip.z);
        const focusPoint = new THREE.Vector3(f_val, 0, 0); 

        if (currentLensType === 'convex') {
            const pts1 = [objTip.clone(), lensHit1.clone()];
            const dir1 = new THREE.Vector3().subVectors(focusPoint, lensHit1).normalize();
            pts1.push(dir1.multiplyScalar(300).add(lensHit1));
            addLine(pts1, rMat); 
            
            if (!isParallel && Math.abs(parseFloat(ui.dist.value)) > 0.1) {
                if (!isReal) {
                     const vPts1 = [imgTip.clone(), lensHit1.clone()];
                     addLine(vPts1, vMat, true);
                }
            }
        } else {
            const pts1 = [objTip.clone(), lensHit1.clone()];
            const dir1 = new THREE.Vector3().subVectors(lensHit1, focusPoint).normalize();
            pts1.push(dir1.multiplyScalar(300).add(lensHit1));
            addLine(pts1, rMat);
            
            const vPts1 = [focusPoint.clone(), lensHit1.clone()];
            addLine(vPts1, vMat, true);
        }

        const center = new THREE.Vector3(0,0,0);
        const dir2 = new THREE.Vector3().subVectors(center, objTip).normalize();
        const pts2 = [objTip.clone(), dir2.multiplyScalar(300).add(objTip)];
        addLine(pts2, rMat);
    }

    function addLine(points, material, isDashed = false) {
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(geometry, material);
        if (isDashed) line.computeLineDistances();
        line.layers.set(0); 
        raysGroup.add(line);
    }

    function updateLayers() {
        cameraTop.layers.enable(0);
        cameraTop.layers.enable(1);
        cameraTop.layers.enable(2);
        cameraEye.layers.disableAll();
        cameraEye.layers.enable(2); 
        
        objArrow.traverse(o => { o.layers.set(1); o.layers.enable(0); });
        imgArrow.traverse(o => { o.layers.set(2); o.layers.enable(0); });
        
        const objKnot = scene.getObjectByName("ObjectKnot");
        const imgKnot = scene.getObjectByName("ImageKnot");
        if(objKnot) objKnot.traverse(o => { o.layers.set(1); o.layers.enable(0); });
        if(imgKnot) imgKnot.traverse(o => { o.layers.set(2); o.layers.enable(0); });
    }

    function render() {
        requestAnimationFrame(render);
        controls.update();

        const width = window.innerWidth;
        const height = window.innerHeight;
        const splitY = Math.floor(height * 0.45); 
        
        divider.style.top = (height - splitY) + "px";
        document.getElementById('label-eye').style.bottom = (splitY - 40) + "px";

        lensMat.stencilWrite = false;
        imageMat.stencilWrite = false;
        lensMat.depthWrite = true; 
        lensMat.side = THREE.DoubleSide;

        renderer.setViewport(0, splitY, width, height - splitY);
        renderer.setScissor(0, splitY, width, height - splitY);
        renderer.setScissorTest(true);
        renderer.setClearColor(0x111111);
        
        cameraTop.aspect = width / (height - splitY);
        cameraTop.updateProjectionMatrix();
        renderer.render(scene, cameraTop);

        renderer.setViewport(0, 0, width, splitY);
        renderer.setScissor(0, 0, width, splitY);
        renderer.setScissorTest(true);
        renderer.setClearColor(0x050505);
        renderer.clearStencil(); 
        
        const activeMesh = (currentLensType === 'convex') ? convexMesh : concaveMesh;
        activeMesh.renderOrder = 1;
        lensMat.stencilWrite = true;
        lensMat.stencilFunc = THREE.AlwaysStencilFunc; 
        lensMat.stencilRef = 1;
        lensMat.stencilZPass = THREE.ReplaceStencilOp;
        lensMat.depthWrite = false;
        lensMat.side = THREE.FrontSide;

        if(currentLensType === 'convex') concaveMesh.renderOrder = 999; 
        else convexMesh.renderOrder = 999;
        
        const activeImg = (currentObjType === 'arrow') ? imgArrow : scene.getObjectByName("ImageKnot");
        if (activeImg) {
            activeImg.renderOrder = 2; 
            activeImg.traverse(child => {
                if(child.material) {
                    child.material.stencilWrite = true;
                    child.material.stencilFunc = THREE.EqualStencilFunc; 
                    child.material.stencilRef = 1;
                }
            });
        }

        cameraEye.aspect = width / splitY;
        cameraEye.updateProjectionMatrix();
        renderer.render(scene, cameraEye);
        lensMat.depthWrite = true;
        lensMat.side = THREE.DoubleSide;
    }

    window.addEventListener('resize', () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    Object.values(ui).forEach(el => {
        if(el instanceof HTMLElement && el.tagName === 'INPUT') {
            el.addEventListener('input', updateSimulation);
        }
    });

    updateSimulation();
    render();
    </script>
</body>
</html>
