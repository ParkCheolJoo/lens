<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Î†åÏ¶à ÏãúÎÆ¨Î†àÏù¥ÌÑ∞</title>
    
    <!-- ÌïÑÏàò ÎùºÏù¥Î∏åÎü¨Î¶¨ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Noto Sans KR', sans-serif; background: #050505; color: white; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* UI Ìå®ÎÑê Ïä§ÌÉÄÏùº */
        .ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(20, 20, 20, 0.9);
            padding: 15px;
            border-radius: 12px;
            width: 260px; /* ÎÑàÎπÑ ÏïΩÍ∞Ñ Ï¶ùÍ∞Ä */
            max-height: 90vh;
            overflow-y: auto;
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255,255,255,0.15);
            user-select: none;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            z-index: 50;
        }
        
        .view-label {
            position: absolute;
            padding: 6px 12px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(74, 222, 128, 0.3);
            border-radius: 6px;
            font-size: 14px;
            font-weight: bold;
            pointer-events: none;
            color: #4ade80;
            z-index: 20;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        #label-main { top: 20px; right: 20px; }
        #label-eye { bottom: 20px; right: 20px; }
        
        .slider-group { margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid #333; }
        .slider-label { display: flex; justify-content: space-between; margin-bottom: 4px; font-size: 0.8em; color: #ccc; }
        
        input[type=range] { 
            width: 100%; cursor: pointer; accent-color: #4ade80; 
            height: 4px; background: #444; border-radius: 2px;
            appearance: none;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px; height: 14px; background: #4ade80; border-radius: 50%;
        }

        /* ÏÑ†ÌÉù Î≤ÑÌäº Ïä§ÌÉÄÏùº (Í≥µÌÜµ) */
        .selector-row {
            display: flex;
            background: #333;
            border-radius: 8px;
            padding: 4px;
            margin-bottom: 12px;
            gap: 4px;
        }
        .selector-opt {
            flex: 1;
            text-align: center;
            padding: 6px 2px;
            cursor: pointer;
            border-radius: 6px;
            font-weight: bold;
            font-size: 0.75rem;
            transition: all 0.2s;
            color: #888;
        }
        .selector-opt.active {
            background: #4ade80;
            color: #000;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .legend { margin-top: 10px; font-size: 0.8em; color: #aaa; }
        .legend-item { display: flex; align-items: center; margin-bottom: 4px; }
        .color-box { width: 12px; height: 12px; margin-right: 8px; border-radius: 2px; }
        
        #divider {
            position: absolute;
            left: 0;
            width: 100%;
            height: 4px;
            background: #222;
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            z-index: 10;
            cursor: ns-resize;
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>
    <div id="divider"></div>

    <div id="label-main" class="view-label">3D ÏûÖÏ≤¥ Í¥ëÏÑ† Ï∂îÏ†Å (Top View)</div>
    <div id="label-eye" class="view-label">ÎààÏúºÎ°ú Î≥∏ Î™®Ïäµ (Observer View)</div>

    <div class="ui-panel">
        <h2 class="text-lg font-bold mb-3 text-green-400 border-b border-gray-600 pb-2">3D Î†åÏ¶à ÏãúÎÆ¨Î†àÏù¥ÌÑ∞</h2>
        
        <!-- Lens Selector -->
        <div class="font-bold text-xs text-white mb-1">Î†åÏ¶à Ï¢ÖÎ•ò (Lens Type)</div>
        <div class="selector-row">
            <div id="btn-convex" class="selector-opt active">Î≥ºÎ°ù (Convex)</div>
            <div id="btn-concave" class="selector-opt">Ïò§Î™© (Concave)</div>
        </div>

        <!-- Object Selector -->
        <div class="font-bold text-xs text-white mb-1">Î¨ºÏ≤¥ Î™®Ïñë (Object Shape)</div>
        <div class="selector-row">
            <div id="btn-obj-arrow" class="selector-opt active">ÌôîÏÇ¥Ìëú (Arrow)</div>
            <div id="btn-obj-knot" class="selector-opt">3D Îß§Îì≠ (Knot)</div>
        </div>

        <div class="slider-group">
            <div class="font-bold text-xs text-white mb-2">‚öôÔ∏è Î†åÏ¶à ÏÑ§Ï†ï (Lens)</div>
            <div class="slider-label">
                <span>Ï¥àÏ†ê Í±∞Î¶¨ (Focal Length)</span>
                <span id="val-focal" class="font-mono text-green-300">15.0</span>
            </div>
            <input type="range" id="input-focal" min="10" max="40" step="0.5" value="15">
            <div id="text-lens-desc" class="text-xs text-gray-500 mt-1">ÏûëÏùÑÏàòÎ°ù Î†åÏ¶àÍ∞Ä ÎëêÍ∫ºÏõåÏßê (Í∞ïÌïú Íµ¥Ï†à)</div>
            
            <div class="slider-label mt-2">
                <span>Î¨ºÏ≤¥ ÌÅ¨Í∏∞ (Size)</span>
                <span id="val-height" class="font-mono text-green-300">5.0</span>
            </div>
            <input type="range" id="input-height" min="2" max="10" step="0.5" value="5">
        </div>

        <div class="slider-group">
            <div class="font-bold text-sm text-white mb-2">üïπÔ∏è ÏúÑÏπò Ï†úÏñ¥ (Position)</div>
            
            <div class="slider-label">
                <span>Í±∞Î¶¨ (Distance X)</span>
                <span id="val-dist" class="font-mono text-green-300">30.0</span>
            </div>
            <input type="range" id="input-dist" min="5" max="60" step="0.5" value="25">
            
            <div class="slider-label mt-2">
                <span>ÎÜíÏù¥ (Vertical Y)</span>
                <span id="val-offset-y" class="font-mono text-green-300">0.0</span>
            </div>
            <input type="range" id="input-offset-y" min="-15" max="15" step="0.5" value="0">

            <div class="slider-label mt-2">
                <span>Ï¢åÏö∞ (Horizontal Z)</span>
                <span id="val-offset-z" class="font-mono text-green-300">5.0</span>
            </div>
            <input type="range" id="input-offset-z" min="-15" max="15" step="0.5" value="5">
        </div>

        <div class="p-3 bg-gray-800 rounded border border-gray-700 mb-2">
            <div class="flex justify-between mb-1 text-sm">
                <span class="text-gray-400">ÏÉÅÏùò Ï¢ÖÎ•ò:</span>
                <span id="info-type" class="font-bold text-white">--</span>
            </div>
            <div class="flex justify-between mb-1 text-sm">
                <span class="text-gray-400">Î∞∞Ïú®:</span>
                <span id="info-mag" class="font-bold text-white">--</span>
            </div>
        </div>

        <div class="legend">
            <div class="legend-item"><div class="color-box bg-red-500"></div>Î¨ºÏ≤¥ (Object)</div>
            <div class="legend-item"><div class="color-box bg-blue-400"></div>ÏÉÅ (Image)</div>
            <div class="legend-item"><div class="color-box bg-yellow-300"></div>Í¥ëÏÑ† (4ÏÉâ Íµ¨Î∂Ñ)</div>
        </div>
    </div>

    <!-- Î°úÏßÅ Ïä§ÌÅ¨Î¶ΩÌä∏ -->
    <script>
    // --- 1. Scene Setup ---
    const container = document.getElementById('canvas-container');
    const divider = document.getElementById('divider');
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false, stencil: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.autoClear = false; 
    container.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);
    scene.fog = new THREE.Fog(0x111111, 80, 250);

    // --- Cameras ---
    const cameraTop = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    cameraTop.position.set(40, 30, 60);
    cameraTop.lookAt(0, 0, 0);

    const cameraEye = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 1000);
    // [Updated] Moved closer (100 -> 66) to make lens appear ~1.5x larger in observer view
    cameraEye.position.set(66, 0, 0); 
    cameraEye.lookAt(0, 0, 0);
    
    // Controls
    const controls = new THREE.OrbitControls(cameraTop, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    // --- 2. Lighting ---
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
    ambientLight.layers.enableAll(); 
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(20, 50, 30);
    dirLight.layers.enableAll();
    scene.add(dirLight);
    
    const rimLight = new THREE.PointLight(0x44aaff, 0.5);
    rimLight.position.set(-20, 0, -20);
    rimLight.layers.enableAll();
    scene.add(rimLight);

    // --- Helpers ---
    const gridHelper = new THREE.GridHelper(200, 40, 0x333333, 0x1a1a1a);
    gridHelper.position.y = -20;
    gridHelper.layers.set(0);
    scene.add(gridHelper);

    const axisGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-200,0,0), new THREE.Vector3(200,0,0)]);
    const axisMat = new THREE.LineBasicMaterial({ color: 0x555555, transparent: true, opacity: 0.5 });
    const axisLine = new THREE.Line(axisGeo, axisMat);
    axisLine.layers.enableAll();
    scene.add(axisLine);

    // --- 3. Objects ---

    // Materials
    const lensMat = new THREE.MeshPhysicalMaterial({
        color: 0xaaccff,
        transmission: 0.95,
        opacity: 1,
        metalness: 0,
        roughness: 0,
        ior: 1.5,
        thickness: 3.0,
        clearcoat: 1.0,
        side: THREE.DoubleSide
    });
    
    const lensRimMat = new THREE.MeshStandardMaterial({
        color: 0x445566,
        roughness: 0.4,
        metalness: 0.8
    });

    const objectMat = new THREE.MeshStandardMaterial({ color: 0xff3333, emissive: 0x440000 });
    const imageMat = new THREE.MeshStandardMaterial({ color: 0x3388ff, emissive: 0x001144, transparent: true, opacity: 0.9 });
    
    const rayMat = new THREE.LineBasicMaterial({ color: 0xffdd00, linewidth: 1, transparent: true, opacity: 0.6 }); // Ray opacity lowered for multiray
    const virtualRayMat = new THREE.LineDashedMaterial({ color: 0xaaaaaa, dashSize: 2, gapSize: 1, scale: 1, transparent: true, opacity: 0.4 });

    // [New] Multi-color materials for 3D Knot rays
    // Colors: Red, Lime, Cyan, Magenta
    const rayColors = [0xff4444, 0x44ff44, 0x44ffff, 0xff44ff];
    const rayMaterials = rayColors.map(c => new THREE.LineBasicMaterial({ color: c, linewidth: 1, transparent: true, opacity: 0.7 }));
    const virtualRayMaterials = rayColors.map(c => new THREE.LineDashedMaterial({ color: c, dashSize: 2, gapSize: 1, scale: 1, transparent: true, opacity: 0.4 }));

    function create3DArrow(material, name) {
        const group = new THREE.Group();
        const stemGeo = new THREE.CylinderGeometry(0.3, 0.3, 1, 16);
        stemGeo.translate(0, 0.5, 0); 
        const stem = new THREE.Mesh(stemGeo, material);
        group.add(stem);
        const headGeo = new THREE.ConeGeometry(0.8, 1.2, 16);
        headGeo.translate(0, 0.6, 0); 
        const head = new THREE.Mesh(headGeo, material);
        head.position.y = 1; 
        group.add(head);
        group.name = name;
        return group;
    }

    function create3DKnot(material, name) {
        // Torus Knot for "Complex 3D Object"
        const geo = new THREE.TorusKnotGeometry(1, 0.3, 64, 16);
        const mesh = new THREE.Mesh(geo, material);
        const group = new THREE.Group();
        group.add(mesh);
        group.name = name;
        return group;
    }

    // --- LENS GEOMETRIES ---
    const lensGroup = new THREE.Group();
    scene.add(lensGroup);

    // 1. Convex Lens
    const convexGeo = new THREE.SphereGeometry(14, 64, 32);
    const convexMesh = new THREE.Mesh(convexGeo, lensMat);
    lensGroup.add(convexMesh);

    // 2. Concave Lens (Lathe)
    const concaveProfile = [];
    const stepsLathe = 20;
    const R_lens = 14;
    const T_center = 1.0; 
    const T_edge = 5.0;   
    
    for (let i = 0; i <= stepsLathe; i++) {
        const r = (i / stepsLathe) * R_lens; 
        const halfThick = (T_center + (T_edge - T_center) * (r/R_lens)**2) / 2;
        concaveProfile.push(new THREE.Vector2(r, halfThick));
    }
    for (let i = stepsLathe; i >= 0; i--) {
        const r = (i / stepsLathe) * R_lens;
        const halfThick = (T_center + (T_edge - T_center) * (r/R_lens)**2) / 2;
        concaveProfile.push(new THREE.Vector2(r, -halfThick));
    }
    
    const concaveGeo = new THREE.LatheGeometry(concaveProfile, 32);
    const concaveMesh = new THREE.Mesh(concaveGeo, lensMat);
    concaveMesh.rotation.z = -Math.PI / 2;
    concaveMesh.visible = false;
    lensGroup.add(concaveMesh);

    // Rim
    const rimGeo = new THREE.TorusGeometry(14, 0.3, 32, 100);
    const rimMesh = new THREE.Mesh(rimGeo, lensRimMat);
    rimMesh.rotation.y = Math.PI / 2;
    lensGroup.add(rimMesh);
    
    lensGroup.traverse(c => { c.layers.enableAll(); });

    // --- OBJECTS (Arrow & Knot) ---
    const objGroup = new THREE.Group();
    scene.add(objGroup);

    // 1. Arrow Objects
    const objArrow = create3DArrow(objectMat, "ObjectArrow");
    const baseSphere = new THREE.Mesh(new THREE.SphereGeometry(0.4), objectMat);
    objArrow.add(baseSphere);
    objGroup.add(objArrow);

    const imgArrow = create3DArrow(imageMat, "ImageArrow");
    const imgBaseSphere = new THREE.Mesh(new THREE.SphereGeometry(0.4), imageMat);
    imgArrow.add(imgBaseSphere);
    objGroup.add(imgArrow);

    // 2. Knot Objects
    const objKnot = create3DKnot(objectMat, "ObjectKnot");
    objGroup.add(objKnot);
    
    const imgKnot = create3DKnot(imageMat, "ImageKnot");
    objGroup.add(imgKnot);
    
    // Initially hide knot
    objKnot.visible = false;
    imgKnot.visible = false;

    // FOCAL POINTS
    const focalGeo = new THREE.SphereGeometry(0.3, 16, 16);
    const focalMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
    const fPoint1 = new THREE.Mesh(focalGeo, focalMat);
    const fPoint2 = new THREE.Mesh(focalGeo, focalMat);
    fPoint1.layers.set(0);
    fPoint2.layers.set(0);
    scene.add(fPoint1);
    scene.add(fPoint2);

    // RAYS Group
    const raysGroup = new THREE.Group();
    raysGroup.layers.set(0);
    scene.add(raysGroup);

    // --- 4. Logic & Simulation ---

    let currentLensType = 'convex';
    let currentObjType = 'arrow'; // 'arrow' or 'knot'

    const ui = {
        dist: document.getElementById('input-dist'),
        offsetY: document.getElementById('input-offset-y'),
        offsetZ: document.getElementById('input-offset-z'),
        focal: document.getElementById('input-focal'),
        height: document.getElementById('input-height'),
        valDist: document.getElementById('val-dist'),
        valOffsetY: document.getElementById('val-offset-y'),
        valOffsetZ: document.getElementById('val-offset-z'),
        valFocal: document.getElementById('val-focal'),
        valHeight: document.getElementById('val-height'),
        infoType: document.getElementById('info-type'),
        infoMag: document.getElementById('info-mag'),
        btnConvex: document.getElementById('btn-convex'),
        btnConcave: document.getElementById('btn-concave'),
        btnObjArrow: document.getElementById('btn-obj-arrow'),
        btnObjKnot: document.getElementById('btn-obj-knot'),
        descText: document.getElementById('text-lens-desc')
    };

    // Lens Toggle
    function setLensType(type) {
        currentLensType = type;
        if (type === 'convex') {
            ui.btnConvex.classList.add('active');
            ui.btnConcave.classList.remove('active');
            convexMesh.visible = true;
            concaveMesh.visible = false;
            ui.descText.textContent = "ÏûëÏùÑÏàòÎ°ù Î†åÏ¶àÍ∞Ä ÎëêÍ∫ºÏõåÏßê (Í∞ïÌïú Íµ¥Ï†à)";
        } else {
            ui.btnConvex.classList.remove('active');
            ui.btnConcave.classList.add('active');
            convexMesh.visible = false;
            concaveMesh.visible = true;
            ui.descText.textContent = "ÏûëÏùÑÏàòÎ°ù Í≥°Î•†Ïù¥ Ïã¨Ìï¥Ïßê (Í∞ïÌïú Î∞úÏÇ∞)";
        }
        updateSimulation();
    }
    
    // Object Toggle
    function setObjType(type) {
        currentObjType = type;
        if (type === 'arrow') {
            ui.btnObjArrow.classList.add('active');
            ui.btnObjKnot.classList.remove('active');
            
            objArrow.visible = true;
            imgArrow.visible = true;
            objKnot.visible = false;
            imgKnot.visible = false;
        } else {
            ui.btnObjArrow.classList.remove('active');
            ui.btnObjKnot.classList.add('active');
            
            objArrow.visible = false;
            imgArrow.visible = false;
            objKnot.visible = true;
            imgKnot.visible = true;
        }
        updateSimulation();
    }

    ui.btnConvex.addEventListener('click', () => setLensType('convex'));
    ui.btnConcave.addEventListener('click', () => setLensType('concave'));
    ui.btnObjArrow.addEventListener('click', () => setObjType('arrow'));
    ui.btnObjKnot.addEventListener('click', () => setObjType('knot'));

    function updateSimulation() {
        const do_val = parseFloat(ui.dist.value);
        let f_val_mag = parseFloat(ui.focal.value);
        
        let f_val = (currentLensType === 'convex') ? f_val_mag : -f_val_mag;

        const h_scale = parseFloat(ui.height.value);
        const off_y = parseFloat(ui.offsetY.value); 
        const off_z = parseFloat(ui.offsetZ.value);

        ui.valDist.textContent = do_val.toFixed(1);
        ui.valOffsetY.textContent = off_y.toFixed(1);
        ui.valOffsetZ.textContent = off_z.toFixed(1);
        ui.valFocal.textContent = f_val_mag.toFixed(1);
        ui.valHeight.textContent = h_scale.toFixed(1);

        // Lens Shape Update
        if (currentLensType === 'convex') {
            const thicknessFactor = 3.0 / f_val_mag; 
            convexMesh.scale.set(thicknessFactor, 1, 1);
        } else {
            const scaleFactor = 20.0 / f_val_mag; 
            concaveMesh.scale.set(1, scaleFactor, 1); 
        }

        // --- Object Positioning ---
        const objPos = new THREE.Vector3(-do_val, off_y, off_z);
        
        // Base Scale for Arrow
        const arrowScale = h_scale / 2.0; 
        
        // Scale for Knot (TorusKnot radius 1)
        const knotScale = h_scale / 2.5;

        // Apply to Active Object
        if (currentObjType === 'arrow') {
            objArrow.position.copy(objPos);
            objArrow.scale.set(arrowScale, arrowScale, arrowScale);
        } else {
            objKnot.position.copy(objPos);
            objKnot.scale.set(knotScale, knotScale, knotScale);
        }

        // Focal Points
        fPoint1.position.set(-f_val_mag, 0, 0);
        fPoint2.position.set(f_val_mag, 0, 0);

        // --- Image Calculation ---
        let di_val = 0;
        let magnification = 0;
        let isReal = true;
        let isParallel = false;

        if (currentLensType === 'convex' && Math.abs(do_val - f_val) < 0.1) {
            isParallel = true;
            di_val = 5000; 
            magnification = 100;
            ui.infoType.textContent = "Ï¥àÏ†ê ÏúÑ (ÏÉÅ ÏóÜÏùå)";
            ui.infoType.style.color = "#ffff00";
        } else {
            di_val = (f_val * do_val) / (do_val - f_val);
            magnification = -di_val / do_val; 

            const imgX = di_val;
            const imgY = off_y * magnification;
            const imgZ = off_z * magnification;
            
            // Set Active Image Position
            let targetImg = (currentObjType === 'arrow') ? imgArrow : imgKnot;
            let targetScale = (currentObjType === 'arrow') ? arrowScale : knotScale;
            
            targetImg.position.set(imgX, imgY, imgZ);
            
            const absMag = Math.abs(magnification);
            targetImg.scale.set(targetScale * absMag, targetScale * absMag, targetScale * absMag);

            // Orientation Logic
            if (magnification < 0) {
                // Real Image (Inverted) - Rotate 180 on X axis
                targetImg.rotation.set(Math.PI, 0, 0); 
            } else {
                // Virtual Image (Upright)
                targetImg.rotation.set(0, 0, 0);
            }

            if (di_val > 0) {
                isReal = true;
                ui.infoType.textContent = "Ïã§ÏÉÅ (ÎèÑÎ¶Ω)";
                ui.infoType.style.color = "#4ade80"; 
            } else {
                isReal = false;
                ui.infoType.textContent = "ÌóàÏÉÅ (Ï†ïÎ¶Ω)";
                ui.infoType.style.color = "#f87171"; 
            }
        }
        
        ui.infoMag.textContent = Math.abs(magnification).toFixed(2) + "Î∞∞";
        
        // Visibility
        const activeImg = (currentObjType === 'arrow') ? imgArrow : imgKnot;
        activeImg.visible = !isParallel;

        if (!isReal) {
             activeImg.children.forEach(m => { if(m.material) m.material.opacity = 0.5; });
        } else {
             activeImg.children.forEach(m => { if(m.material) m.material.opacity = 1.0; });
        }

        // --- Multi-Ray Tracing ---
        
        // Define Source Points (Relative to Object Center)
        let sourcePointsLocal = [];
        
        if (currentObjType === 'arrow') {
            // Arrow: Just Tip
            // Tip local Y is ~2.2 * scale (Stem 1 + Head 1.2)
            // But we can just use a fixed relative point scaled by object scale
            // Local Tip is (0, 2.2, 0)
            sourcePointsLocal.push(new THREE.Vector3(0, 2.2 * arrowScale, 0));
        } else {
            // Knot: 4 cardinal points to show 3D nature
            // TorusKnot(1, 0.3) -> Approx radius 1.3
            const r = 1.3 * knotScale;
            sourcePointsLocal.push(new THREE.Vector3(0, r, 0));   // Top
            sourcePointsLocal.push(new THREE.Vector3(0, -r, 0));  // Bottom
            sourcePointsLocal.push(new THREE.Vector3(0, 0, r));   // Front/Right
            sourcePointsLocal.push(new THREE.Vector3(0, 0, -r));  // Back/Left
        }
        
        // Clear Rays First
        while(raysGroup.children.length > 0){ 
            const obj = raysGroup.children.pop();
            if(obj.geometry) obj.geometry.dispose();
            raysGroup.remove(obj); 
        }

        // Trace for each point
        sourcePointsLocal.forEach((localPt, index) => {
            // Convert to World Pos
            const objTip = new THREE.Vector3().copy(localPt).add(objPos);
            
            // Calculate Image Point World Pos
            let imgTip;
            if (isParallel) {
                imgTip = new THREE.Vector3(1000, 0, 0);
            } else {
                // Apply magnification to local offset, then add to image center
                // Magnification inverts local coords if negative
                const imgOffset = localPt.clone().multiplyScalar(magnification);
                // Also, rotation X=180 handles inversion for mesh, but for points we calculate manually
                // If mag < 0, y -> -y, z -> -z. 
                // The formula above (multiplyScalar) handles sign correctly.
                
                // Image Center
                const imgCenter = new THREE.Vector3(di_val, off_y * magnification, off_z * magnification);
                imgTip = new THREE.Vector3().copy(imgCenter).add(imgOffset);
            }
            
            // Pass index to select color. -1 means default yellow (Arrow)
            const colorIndex = (currentObjType === 'arrow') ? -1 : index;
            draw3DRays(objTip, imgTip, f_val, isReal, isParallel, colorIndex);
        });
        
        updateLayers();
    }

    // [Updated] Generic Trace Function now accepts colorIndex
    function draw3DRays(objTip, imgTip, f_val, isReal, isParallel, colorIndex) {
        
        // Select Materials based on colorIndex
        let rMat, vMat;
        if (colorIndex === -1) {
            rMat = rayMat; // Default Yellow
            vMat = virtualRayMat;
        } else {
            // Cycle through defined colors if more than 4 points
            rMat = rayMaterials[colorIndex % rayMaterials.length];
            vMat = virtualRayMaterials[colorIndex % virtualRayMaterials.length];
        }

        // Ray 1: Parallel to Axis -> Refracts through Focus
        const lensHit1 = new THREE.Vector3(0, objTip.y, objTip.z);
        
        if (currentLensType === 'convex') {
            const focusPoint = new THREE.Vector3(f_val, 0, 0); 
            const pts1 = [objTip.clone(), lensHit1.clone()];
            const dir1 = new THREE.Vector3().subVectors(focusPoint, lensHit1).normalize();
            pts1.push(dir1.multiplyScalar(200).add(lensHit1));
            addLine(pts1, rMat); // Use chosen material
            
            if (!isReal && !isParallel) {
                const vPts1 = [imgTip.clone(), lensHit1.clone()];
                addLine(vPts1, vMat, true); // Use chosen material
            }
        } else {
            const focusPoint = new THREE.Vector3(f_val, 0, 0); 
            const pts1 = [objTip.clone(), lensHit1.clone()];
            const dir1 = new THREE.Vector3().subVectors(lensHit1, focusPoint).normalize(); // Diverge
            pts1.push(dir1.multiplyScalar(200).add(lensHit1));
            addLine(pts1, rMat);
            
            const vPts1 = [focusPoint.clone(), lensHit1.clone()];
            addLine(vPts1, vMat, true);
        }

        // Ray 2: Center (Undeviated)
        const center = new THREE.Vector3(0,0,0);
        const dir2 = new THREE.Vector3().subVectors(center, objTip).normalize();
        const pts2 = [objTip.clone(), dir2.multiplyScalar(200).add(objTip)];
        addLine(pts2, rMat);
        
        // (Ray 3 omitted for multi-point to prevent visual overload, 2 rays per point is sufficient for 3D demo)
    }

    function addLine(points, material, isDashed = false) {
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(geometry, material);
        if (isDashed) line.computeLineDistances();
        line.layers.set(0); 
        raysGroup.add(line);
    }

    function updateLayers() {
        cameraTop.layers.enable(0);
        cameraTop.layers.enable(1);
        cameraTop.layers.enable(2);

        cameraEye.layers.disableAll();
        cameraEye.layers.enable(2); 
        
        // Visibility Layers
        // Object Layer (1), Image Layer (2)
        // Arrows
        objArrow.traverse(o => { o.layers.set(1); o.layers.enable(0); });
        imgArrow.traverse(o => { o.layers.set(2); o.layers.enable(0); });
        
        // Knots
        const objKnot = scene.getObjectByName("ObjectKnot");
        const imgKnot = scene.getObjectByName("ImageKnot");
        if(objKnot) objKnot.traverse(o => { o.layers.set(1); o.layers.enable(0); });
        if(imgKnot) imgKnot.traverse(o => { o.layers.set(2); o.layers.enable(0); });
    }

    function render() {
        requestAnimationFrame(render);
        controls.update();

        const width = window.innerWidth;
        const height = window.innerHeight;
        const splitY = Math.floor(height * 0.45); 
        
        divider.style.top = (height - splitY) + "px";
        document.getElementById('label-eye').style.bottom = (splitY - 40) + "px";

        // Top View
        lensMat.stencilWrite = false;
        imageMat.stencilWrite = false;
        lensMat.depthWrite = true; 
        lensMat.side = THREE.DoubleSide;

        renderer.setViewport(0, splitY, width, height - splitY);
        renderer.setScissor(0, splitY, width, height - splitY);
        renderer.setScissorTest(true);
        renderer.setClearColor(0x111111);
        
        cameraTop.aspect = width / (height - splitY);
        cameraTop.updateProjectionMatrix();
        renderer.render(scene, cameraTop);

        // Bottom View
        renderer.setViewport(0, 0, width, splitY);
        renderer.setScissor(0, 0, width, splitY);
        renderer.setScissorTest(true);
        renderer.setClearColor(0x050505);
        
        renderer.clearStencil(); 
        
        const activeMesh = (currentLensType === 'convex') ? convexMesh : concaveMesh;
        
        activeMesh.renderOrder = 1;
        lensMat.stencilWrite = true;
        lensMat.stencilFunc = THREE.AlwaysStencilFunc; 
        lensMat.stencilRef = 1;
        lensMat.stencilZPass = THREE.ReplaceStencilOp;
        lensMat.depthWrite = false;
        lensMat.side = THREE.FrontSide;

        if(currentLensType === 'convex') concaveMesh.renderOrder = 999; 
        else convexMesh.renderOrder = 999;
        
        // Determine active image object
        const activeImg = (currentObjType === 'arrow') ? imgArrow : scene.getObjectByName("ImageKnot");

        if (activeImg) {
            activeImg.renderOrder = 2; 
            activeImg.traverse(child => {
                if(child.material) {
                    child.material.stencilWrite = true;
                    child.material.stencilFunc = THREE.EqualStencilFunc; 
                    child.material.stencilRef = 1;
                }
            });
        }

        cameraEye.aspect = width / splitY;
        cameraEye.updateProjectionMatrix();
        renderer.render(scene, cameraEye);

        lensMat.depthWrite = true;
        lensMat.side = THREE.DoubleSide;
    }

    window.addEventListener('resize', () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    Object.values(ui).forEach(el => {
        if(el instanceof HTMLElement && el.tagName === 'INPUT') {
            el.addEventListener('input', updateSimulation);
        }
    });

    // Init
    updateSimulation();
    render();
    </script>
</body>
</html>
