<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Î†åÏ¶à ÏãúÎÆ¨Î†àÏù¥ÌÑ∞</title>
    
    <!-- Ìè∞Ìä∏ Î∞è ÎùºÏù¥Î∏åÎü¨Î¶¨ -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Noto Sans KR', sans-serif; background: #050505; color: white; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* UI Ìå®ÎÑê Ïä§ÌÉÄÏùº */
        .ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(20, 20, 20, 0.9);
            padding: 15px;
            border-radius: 12px;
            width: 260px;
            max-height: 90vh;
            overflow-y: auto;
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255,255,255,0.15);
            user-select: none;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            z-index: 50;
        }
        
        /* Ïä§ÌÅ¨Î°§Î∞î Ïª§Ïä§ÌÖÄ */
        .ui-panel::-webkit-scrollbar { width: 6px; }
        .ui-panel::-webkit-scrollbar-track { background: #222; }
        .ui-panel::-webkit-scrollbar-thumb { background: #444; border-radius: 3px; }
        
        /* Î∑∞ ÎùºÎ≤® Ïä§ÌÉÄÏùº */
        .view-label {
            position: absolute;
            padding: 6px 12px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(74, 222, 128, 0.3);
            border-radius: 6px;
            font-size: 14px;
            font-weight: bold;
            pointer-events: none;
            color: #4ade80;
            z-index: 20;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        #label-main { top: 20px; right: 20px; }
        #label-eye { bottom: 20px; right: 20px; }
        
        /* Ïä¨ÎùºÏù¥Îçî Ïä§ÌÉÄÏùº */
        .slider-group { margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid #333; }
        .slider-label { display: flex; justify-content: space-between; margin-bottom: 4px; font-size: 0.8em; color: #ccc; }
        
        input[type=range] { 
            width: 100%; cursor: pointer; accent-color: #4ade80; 
            height: 4px; background: #444; border-radius: 2px;
            appearance: none;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px; height: 14px; background: #4ade80; border-radius: 50%;
        }

        /* ÏÑ†ÌÉù Î≤ÑÌäº Ïä§ÌÉÄÏùº */
        .selector-row {
            display: flex;
            background: #333;
            border-radius: 8px;
            padding: 4px;
            margin-bottom: 12px;
            gap: 4px;
        }
        .selector-opt {
            flex: 1;
            text-align: center;
            padding: 6px 2px;
            cursor: pointer;
            border-radius: 6px;
            font-weight: bold;
            font-size: 0.75rem;
            transition: all 0.2s;
            color: #888;
        }
        .selector-opt.active {
            background: #4ade80;
            color: #000;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .legend { margin-top: 10px; font-size: 0.8em; color: #aaa; }
        .legend-item { display: flex; align-items: center; margin-bottom: 4px; }
        .color-box { width: 12px; height: 12px; margin-right: 8px; border-radius: 2px; }
        
        /* ÌôîÎ©¥ Î∂ÑÌï† ÏÑ† */
        #divider {
            position: absolute;
            left: 0;
            width: 100%;
            height: 4px;
            background: #222;
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            z-index: 10;
            cursor: ns-resize;
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>
    <div id="divider"></div>

    <div id="label-main" class="view-label">3D ÏûÖÏ≤¥ Í¥ëÏÑ† Ï∂îÏ†Å (Top View)</div>
    <div id="label-eye" class="view-label">ÎààÏúºÎ°ú Î≥∏ Î™®Ïäµ (Observer View)</div>

    <div class="ui-panel">
        <h2 class="text-lg font-bold mb-3 text-green-400 border-b border-gray-600 pb-2">3D Î†åÏ¶à ÏãúÎÆ¨Î†àÏù¥ÌÑ∞</h2>
        
        <!-- Lens Selector -->
        <div class="font-bold text-xs text-white mb-1">Î†åÏ¶à Ï¢ÖÎ•ò (Lens Type)</div>
        <div class="selector-row">
            <div id="btn-convex" class="selector-opt active">Î≥ºÎ°ù (Convex)</div>
            <div id="btn-concave" class="selector-opt">Ïò§Î™© (Concave)</div>
        </div>

        <!-- Object Selector -->
        <div class="font-bold text-xs text-white mb-1">Î¨ºÏ≤¥ Î™®Ïñë (Object Shape)</div>
        <div class="selector-row">
            <div id="btn-obj-arrow" class="selector-opt active">ÌôîÏÇ¥Ìëú (Arrow)</div>
            <div id="btn-obj-knot" class="selector-opt">3D Îß§Îì≠ (Knot)</div>
        </div>

        <div class="slider-group">
            <div class="font-bold text-xs text-white mb-2">‚öôÔ∏è Î†åÏ¶à ÏÑ§Ï†ï (Lens)</div>
            <div class="slider-label">
                <span>Ï¥àÏ†ê Í±∞Î¶¨ (Focal Length)</span>
                <span id="val-focal" class="font-mono text-green-300">15.0</span>
            </div>
            <input type="range" id="input-focal" min="10" max="40" step="0.5" value="15">
            <div id="text-lens-desc" class="text-xs text-gray-500 mt-1">ÏûëÏùÑÏàòÎ°ù Î†åÏ¶àÍ∞Ä ÎëêÍ∫ºÏõåÏßê (Í∞ïÌïú Íµ¥Ï†à)</div>
            
            <div class="slider-label mt-2">
                <span>Î¨ºÏ≤¥ ÌÅ¨Í∏∞ (Size)</span>
                <span id="val-height" class="font-mono text-green-300">5.0</span>
            </div>
            <input type="range" id="input-height" min="2" max="10" step="0.5" value="5">
        </div>

        <div class="slider-group">
            <div class="font-bold text-sm text-white mb-2">üïπÔ∏è ÏúÑÏπò Ï†úÏñ¥ (Position)</div>
            
            <div class="slider-label">
                <span>Í±∞Î¶¨ (Distance X)</span>
                <span id="val-dist" class="font-mono text-green-300">30.0</span>
            </div>
            <input type="range" id="input-dist" min="5" max="60" step="0.5" value="30">
            
            <div class="slider-label mt-2">
                <span>ÎÜíÏù¥ (Vertical Y)</span>
                <span id="val-offset-y" class="font-mono text-green-300">0.0</span>
            </div>
            <input type="range" id="input-offset-y" min="-15" max="15" step="0.5" value="0">

            <div class="slider-label mt-2">
                <span>Ï¢åÏö∞ (Horizontal Z)</span>
                <span id="val-offset-z" class="font-mono text-green-300">0.0</span>
            </div>
            <input type="range" id="input-offset-z" min="-15" max="15" step="0.5" value="0">
        </div>

        <!-- Rotation Control -->
        <div class="slider-group">
            <div class="font-bold text-sm text-white mb-2">üîÑ ÌöåÏ†Ñ (Rotation)</div>
            
            <div class="slider-label">
                <span>XÏ∂ï ÌöåÏ†Ñ (Pitch)</span>
                <span id="val-rot-x" class="font-mono text-blue-300">0¬∞</span>
            </div>
            <input type="range" id="input-rot-x" min="-360" max="360" step="5" value="0">

            <div class="slider-label mt-2">
                <span>YÏ∂ï ÌöåÏ†Ñ (Yaw)</span>
                <span id="val-rot-y" class="font-mono text-blue-300">0¬∞</span>
            </div>
            <input type="range" id="input-rot-y" min="-360" max="360" step="5" value="0">

            <div class="slider-label mt-2">
                <span>ZÏ∂ï ÌöåÏ†Ñ (Roll)</span>
                <span id="val-rot-z" class="font-mono text-blue-300">0¬∞</span>
            </div>
            <input type="range" id="input-rot-z" min="-360" max="360" step="5" value="0">
        </div>

        <div class="p-3 bg-gray-800 rounded border border-gray-700 mb-2">
            <div class="flex justify-between mb-1 text-sm">
                <span class="text-gray-400">ÏÉÅÏùò Ï¢ÖÎ•ò:</span>
                <span id="info-type" class="font-bold text-white">--</span>
            </div>
            <div class="flex justify-between mb-1 text-sm">
                <span class="text-gray-400">Î∞∞Ïú®(Ï§ëÏã¨):</span>
                <span id="info-mag" class="font-bold text-white">--</span>
            </div>
        </div>

        <div class="legend">
            <div class="legend-item"><div class="color-box bg-red-500"></div>Î¨ºÏ≤¥ (Object)</div>
            <div class="legend-item"><div class="color-box bg-blue-400"></div>ÏÉÅ (Image)</div>
            <div class="legend-item"><div class="color-box bg-yellow-300"></div>Í¥ëÏÑ† (4ÏÉâ Íµ¨Î∂Ñ)</div>
        </div>
    </div>

    <!-- Î°úÏßÅ Ïä§ÌÅ¨Î¶ΩÌä∏ -->
    <script>
    // --- 1. Scene Setup ---
    const container = document.getElementById('canvas-container');
    const divider = document.getElementById('divider');
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false, stencil: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.autoClear = false; 
    container.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);
    scene.fog = new THREE.Fog(0x111111, 80, 250);

    // --- Cameras ---
    const cameraTop = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    cameraTop.position.set(40, 30, 60);
    cameraTop.lookAt(0, 0, 0);

    const cameraEye = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 1000);
    cameraEye.position.set(66, 0, 0); 
    cameraEye.lookAt(0, 0, 0);
    
    const controls = new THREE.OrbitControls(cameraTop, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    // --- 2. Lighting ---
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
    ambientLight.layers.enableAll(); 
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(20, 50, 30);
    dirLight.layers.enableAll();
    scene.add(dirLight);
    
    const rimLight = new THREE.PointLight(0x44aaff, 0.5);
    rimLight.position.set(-20, 0, -20);
    rimLight.layers.enableAll();
    scene.add(rimLight);

    // --- Helpers ---
    const gridHelper = new THREE.GridHelper(200, 40, 0x333333, 0x1a1a1a);
    gridHelper.position.y = -20;
    gridHelper.layers.set(0);
    scene.add(gridHelper);

    const axisGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-200,0,0), new THREE.Vector3(200,0,0)]);
    const axisMat = new THREE.LineBasicMaterial({ color: 0x555555, transparent: true, opacity: 0.5 });
    const axisLine = new THREE.Line(axisGeo, axisMat);
    axisLine.layers.enableAll();
    scene.add(axisLine);

    // --- 3. Objects ---
    const lensMat = new THREE.MeshPhysicalMaterial({
        color: 0xaaccff, transmission: 0.95, opacity: 1, metalness: 0, roughness: 0,
        ior: 1.5, thickness: 3.0, clearcoat: 1.0, side: THREE.DoubleSide
    });
    
    const lensRimMat = new THREE.MeshStandardMaterial({ color: 0x445566, roughness: 0.4, metalness: 0.8 });
    const objectMat = new THREE.MeshStandardMaterial({ color: 0xff3333, emissive: 0x440000 });
    const imageMat = new THREE.MeshStandardMaterial({ color: 0x3388ff, emissive: 0x001144, transparent: true, opacity: 0.9 });
    
    const rayMat = new THREE.LineBasicMaterial({ color: 0xffdd00, linewidth: 1, transparent: true, opacity: 0.6 });
    const virtualRayMat = new THREE.LineDashedMaterial({ color: 0xaaaaaa, dashSize: 2, gapSize: 1, scale: 1, transparent: true, opacity: 0.4 });

    const rayColors = [0xff4444, 0x44ff44, 0x44ffff, 0xff44ff];
    const rayMaterials = rayColors.map(c => new THREE.LineBasicMaterial({ color: c, linewidth: 1, transparent: true, opacity: 0.7 }));
    const virtualRayMaterials = rayColors.map(c => new THREE.LineDashedMaterial({ color: c, dashSize: 2, gapSize: 1, scale: 1, transparent: true, opacity: 0.4 }));

    function create3DArrow(material, name) {
        const group = new THREE.Group();
        // Pivot is at (0,0,0)
        const stemGeo = new THREE.CylinderGeometry(0.3, 0.3, 1, 16);
        stemGeo.translate(0, 0.5, 0); // Stem 0 to 1
        const stem = new THREE.Mesh(stemGeo, material);
        group.add(stem);
        const headGeo = new THREE.ConeGeometry(0.8, 1.2, 16);
        headGeo.translate(0, 0.6, 0); // Head starts at 0, height 1.2. Translate to align base at 0
        const head = new THREE.Mesh(headGeo, material);
        head.position.y = 1; // Head base at 1. Tip at 2.2
        group.add(head);
        group.name = name;
        return group;
    }

    function create3DKnot(material, name) {
        const geo = new THREE.TorusKnotGeometry(1, 0.3, 64, 16);
        const mesh = new THREE.Mesh(geo, material);
        const group = new THREE.Group();
        group.add(mesh);
        group.name = name;
        return group;
    }

    // --- LENS GEOMETRIES ---
    const lensGroup = new THREE.Group();
    scene.add(lensGroup);

    const convexGeo = new THREE.SphereGeometry(14, 64, 32);
    const convexMesh = new THREE.Mesh(convexGeo, lensMat);
    lensGroup.add(convexMesh);

    const concaveProfile = [];
    const stepsLathe = 20;
    const R_lens = 14;
    const T_center = 1.0; 
    const T_edge = 5.0;   
    for (let i = 0; i <= stepsLathe; i++) {
        const r = (i / stepsLathe) * R_lens; 
        const halfThick = (T_center + (T_edge - T_center) * (r/R_lens)**2) / 2;
        concaveProfile.push(new THREE.Vector2(r, halfThick));
    }
    for (let i = stepsLathe; i >= 0; i--) {
        const r = (i / stepsLathe) * R_lens;
        const halfThick = (T_center + (T_edge - T_center) * (r/R_lens)**2) / 2;
        concaveProfile.push(new THREE.Vector2(r, -halfThick));
    }
    const concaveGeo = new THREE.LatheGeometry(concaveProfile, 32);
    const concaveMesh = new THREE.Mesh(concaveGeo, lensMat);
    concaveMesh.rotation.z = -Math.PI / 2;
    concaveMesh.visible = false;
    lensGroup.add(concaveMesh);

    const rimGeo = new THREE.TorusGeometry(14, 0.3, 32, 100);
    const rimMesh = new THREE.Mesh(rimGeo, lensRimMat);
    rimMesh.rotation.y = Math.PI / 2;
    lensGroup.add(rimMesh);
    lensGroup.traverse(c => { c.layers.enableAll(); });

    // --- OBJECTS ---
    const objGroup = new THREE.Group();
    scene.add(objGroup);

    const objArrow = create3DArrow(objectMat, "ObjectArrow");
    const baseSphere = new THREE.Mesh(new THREE.SphereGeometry(0.4), objectMat);
    objArrow.add(baseSphere);
    objGroup.add(objArrow);

    const imgArrow = create3DArrow(imageMat, "ImageArrow");
    const imgBaseSphere = new THREE.Mesh(new THREE.SphereGeometry(0.4), imageMat);
    imgArrow.add(imgBaseSphere);
    objGroup.add(imgArrow);

    const objKnot = create3DKnot(objectMat, "ObjectKnot");
    objGroup.add(objKnot);
    const imgKnot = create3DKnot(imageMat, "ImageKnot");
    objGroup.add(imgKnot);
    
    objKnot.visible = false;
    imgKnot.visible = false;

    // FOCAL POINTS
    const focalGeo = new THREE.SphereGeometry(0.3, 16, 16);
    const focalMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
    const fPoint1 = new THREE.Mesh(focalGeo, focalMat);
    const fPoint2 = new THREE.Mesh(focalGeo, focalMat);
    fPoint1.layers.set(0);
    fPoint2.layers.set(0);
    scene.add(fPoint1);
    scene.add(fPoint2);

    const raysGroup = new THREE.Group();
    raysGroup.layers.set(0);
    scene.add(raysGroup);

    // --- 4. Logic & Simulation ---
    let currentLensType = 'convex';
    let currentObjType = 'arrow';

    const ui = {
        dist: document.getElementById('input-dist'),
        offsetY: document.getElementById('input-offset-y'),
        offsetZ: document.getElementById('input-offset-z'),
        focal: document.getElementById('input-focal'),
        height: document.getElementById('input-height'),
        rotX: document.getElementById('input-rot-x'),
        rotY: document.getElementById('input-rot-y'),
        rotZ: document.getElementById('input-rot-z'),
        valDist: document.getElementById('val-dist'),
        valOffsetY: document.getElementById('val-offset-y'),
        valOffsetZ: document.getElementById('val-offset-z'),
        valFocal: document.getElementById('val-focal'),
        valHeight: document.getElementById('val-height'),
        valRotX: document.getElementById('val-rot-x'),
        valRotY: document.getElementById('val-rot-y'),
        valRotZ: document.getElementById('val-rot-z'),
        infoType: document.getElementById('info-type'),
        infoMag: document.getElementById('info-mag'),
        btnConvex: document.getElementById('btn-convex'),
        btnConcave: document.getElementById('btn-concave'),
        btnObjArrow: document.getElementById('btn-obj-arrow'),
        btnObjKnot: document.getElementById('btn-obj-knot'),
        descText: document.getElementById('text-lens-desc')
    };

    function setLensType(type) {
        currentLensType = type;
        if (type === 'convex') {
            ui.btnConvex.classList.add('active');
            ui.btnConcave.classList.remove('active');
            convexMesh.visible = true;
            concaveMesh.visible = false;
            ui.descText.textContent = "ÏûëÏùÑÏàòÎ°ù Î†åÏ¶àÍ∞Ä ÎëêÍ∫ºÏõåÏßê (Í∞ïÌïú Íµ¥Ï†à)";
        } else {
            ui.btnConvex.classList.remove('active');
            ui.btnConcave.classList.add('active');
            convexMesh.visible = false;
            concaveMesh.visible = true;
            ui.descText.textContent = "ÏûëÏùÑÏàòÎ°ù Í≥°Î•†Ïù¥ Ïã¨Ìï¥Ïßê (Í∞ïÌïú Î∞úÏÇ∞)";
        }
        updateSimulation();
    }
    
    function setObjType(type) {
        currentObjType = type;
        if (type === 'arrow') {
            ui.btnObjArrow.classList.add('active');
            ui.btnObjKnot.classList.remove('active');
            objArrow.visible = true;
            imgArrow.visible = true;
            objKnot.visible = false;
            imgKnot.visible = false;
        } else {
            ui.btnObjArrow.classList.remove('active');
            ui.btnObjKnot.classList.add('active');
            objArrow.visible = false;
            imgArrow.visible = false;
            objKnot.visible = true;
            imgKnot.visible = true;
        }
        updateSimulation();
    }

    ui.btnConvex.addEventListener('click', () => setLensType('convex'));
    ui.btnConcave.addEventListener('click', () => setLensType('concave'));
    ui.btnObjArrow.addEventListener('click', () => setObjType('arrow'));
    ui.btnObjKnot.addEventListener('click', () => setObjType('knot'));

    // [New] Core Optical Calculation Function
    // Calculates the image position for a given object point (world coordinates)
    function computeImagePos(worldPoint, f) {
        // Optical Axis is X. Lens is at x=0. Object usually at x < 0.
        // We define distance 'do' as positive distance from lens.
        // But for calculation, we can stick to Cartesian: x_obj.
        // Lens formula: 1/do + 1/di = 1/f
        // do = -x_obj (if object is left)
        // di = (f * do) / (do - f)
        // Image x = di
        // Magnification M = -di/do
        // Image y = Object y * M
        // Image z = Object z * M
        
        const do_dist = -worldPoint.x;
        
        // Singularity check (close to focal point)
        if (Math.abs(do_dist - f) < 0.01) {
             return new THREE.Vector3(10000 * Math.sign(f), worldPoint.y * 100, worldPoint.z * 100); // Infinity
        }

        const di_dist = (f * do_dist) / (do_dist - f);
        const M = -di_dist / do_dist;
        
        // Resulting image point
        return new THREE.Vector3(di_dist, worldPoint.y * M, worldPoint.z * M);
    }

    function updateSimulation() {
        const do_val = parseFloat(ui.dist.value);
        let f_val_mag = parseFloat(ui.focal.value);
        let f_val = (currentLensType === 'convex') ? f_val_mag : -f_val_mag;
        const h_scale = parseFloat(ui.height.value);
        const off_y = parseFloat(ui.offsetY.value); 
        const off_z = parseFloat(ui.offsetZ.value);
        
        const rot_x_deg = parseFloat(ui.rotX.value);
        const rot_y_deg = parseFloat(ui.rotY.value);
        const rot_z_deg = parseFloat(ui.rotZ.value);
        const rad_x = THREE.MathUtils.degToRad(rot_x_deg);
        const rad_y = THREE.MathUtils.degToRad(rot_y_deg);
        const rad_z = THREE.MathUtils.degToRad(rot_z_deg);

        ui.valDist.textContent = do_val.toFixed(1);
        ui.valOffsetY.textContent = off_y.toFixed(1);
        ui.valOffsetZ.textContent = off_z.toFixed(1);
        ui.valFocal.textContent = f_val_mag.toFixed(1);
        ui.valHeight.textContent = h_scale.toFixed(1);
        ui.valRotX.textContent = rot_x_deg + "¬∞";
        ui.valRotY.textContent = rot_y_deg + "¬∞";
        ui.valRotZ.textContent = rot_z_deg + "¬∞";

        // Lens Shape
        if (currentLensType === 'convex') {
            const thicknessFactor = 3.0 / f_val_mag; 
            convexMesh.scale.set(thicknessFactor, 1, 1);
        } else {
            const scaleFactor = 20.0 / f_val_mag; 
            concaveMesh.scale.set(1, scaleFactor, 1); 
        }

        // Object Transform
        const objPos = new THREE.Vector3(-do_val, off_y, off_z);
        const objRotation = new THREE.Euler(rad_x, rad_y, rad_z, 'XYZ');
        const arrowScale = h_scale / 2.0; 
        const knotScale = h_scale / 2.5;

        // Apply to Objects
        if (currentObjType === 'arrow') {
            objArrow.position.copy(objPos);
            objArrow.scale.set(arrowScale, arrowScale, arrowScale);
            objArrow.rotation.copy(objRotation);
        } else {
            objKnot.position.copy(objPos);
            objKnot.scale.set(knotScale, knotScale, knotScale);
            objKnot.rotation.copy(objRotation);
        }

        // Focal Points
        fPoint1.position.set(-f_val_mag, 0, 0);
        fPoint2.position.set(f_val_mag, 0, 0);

        // --- Optical Calculation for Center (for UI info) ---
        let center_di_val = 0;
        let center_magnification = 0;
        let isReal = true;
        let isParallel = false;

        // Simple calc for center just to get info state
        if (Math.abs(do_val) < 0.1) {
            isParallel = false;
            center_magnification = 1;
            ui.infoType.textContent = "Î†åÏ¶à Ï§ëÏã¨ (ÏùºÏπò)";
            ui.infoType.style.color = "#ffffff";
            isReal = false; 
        } 
        else if (currentLensType === 'convex' && Math.abs(do_val - f_val) < 0.1) {
            isParallel = true;
            ui.infoType.textContent = "Ï¥àÏ†ê ÏúÑ (ÏÉÅ ÏóÜÏùå)";
            ui.infoType.style.color = "#ffff00";
        } else {
            center_di_val = (f_val * do_val) / (do_val - f_val);
            center_magnification = -center_di_val / do_val; 

            if (center_di_val > 0) {
                isReal = true;
                ui.infoType.textContent = "Ïã§ÏÉÅ (ÎèÑÎ¶Ω)";
                ui.infoType.style.color = "#4ade80"; 
            } else {
                isReal = false;
                ui.infoType.textContent = "ÌóàÏÉÅ (Ï†ïÎ¶Ω)";
                ui.infoType.style.color = "#f87171"; 
            }
        }
        ui.infoMag.textContent = Math.abs(center_magnification).toFixed(2) + "Î∞∞";

        // --- Advanced Image Placement (Fitting) ---
        // Instead of just scaling the mesh, we calculate Head and Tail image positions 
        // and fit the mesh between them. This handles Z-rotation distortion correctly.

        let targetImg = (currentObjType === 'arrow') ? imgArrow : imgKnot;
        
        targetImg.visible = !isParallel;
        if (!isReal) {
             targetImg.children.forEach(m => { if(m.material) m.material.opacity = 0.5; });
        } else {
             targetImg.children.forEach(m => { if(m.material) m.material.opacity = 1.0; });
        }

        if (!isParallel) {
            if (currentObjType === 'arrow') {
                // 1. Calculate World Position of Object Base and Tip
                // Arrow pivot is at Base (0,0,0) local
                const objBaseLocal = new THREE.Vector3(0,0,0);
                const objTipLocal = new THREE.Vector3(0, 2.2 * arrowScale, 0); // Approx height 2.2 unscaled

                // To World
                const objBaseWorld = objBaseLocal.clone().applyEuler(objRotation).add(objPos);
                const objTipWorld = objTipLocal.clone().applyEuler(objRotation).add(objPos);

                // 2. Compute Optical Image Positions
                const imgBaseWorld = computeImagePos(objBaseWorld, f_val);
                const imgTipWorld = computeImagePos(objTipWorld, f_val);

                // 3. Fit Image Mesh
                // Place mesh at Image Base
                targetImg.position.copy(imgBaseWorld);

                // Orient mesh to point to Image Tip
                // Original Arrow points Y+ (0,1,0)
                const imgVector = new THREE.Vector3().subVectors(imgTipWorld, imgBaseWorld);
                const imgLength = imgVector.length();

                if (imgLength > 0.001) {
                    const dir = imgVector.clone().normalize();
                    targetImg.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), dir);
                }

                // Scale mesh
                // Y-scale (Length) determined by distance between calculated points
                // X, Z scale (Thickness) determined by transverse magnification at the center
                // Transverse Mag = |center_magnification|
                // Wait, thickness should scale with local transverse mag, let's use center mag approx for thickness
                const thicknessScale = arrowScale * Math.abs(center_magnification);
                
                // Original height was 2.2 * arrowScale. We want it to be imgLength.
                // ScaleY * (2.2) = imgLength  (Note: arrowScale is already baked into 2.2 logic? No, geometry is size ~2.2)
                // Geometry Height is ~2.2.
                // We want final size to be imgLength.
                // So scaleY = imgLength / 2.2
                const geomHeight = 2.2; 
                targetImg.scale.set(thicknessScale, imgLength / geomHeight, thicknessScale);

            } else {
                // Knot Logic (Simplified: Just use center mag scaling as it's a blob)
                // Or we could try to orient it, but it's isotropic-ish.
                // Let's stick to the previous logic for Knot but update position correctly
                const imgCenter = computeImagePos(objPos, f_val);
                targetImg.position.copy(imgCenter);
                
                // Rotation
                targetImg.rotation.copy(objRotation);
                if (center_magnification < 0) {
                     targetImg.rotateOnWorldAxis(new THREE.Vector3(1, 0, 0), Math.PI);
                }

                // Scale
                const absMag = Math.abs(center_magnification);
                targetImg.scale.set(knotScale * absMag, knotScale * absMag, knotScale * absMag);
            }
        }

        // --- Multi-Ray Tracing ---
        // Ray Source Points
        let sourcePointsLocal = [];
        if (currentObjType === 'arrow') {
            const s = arrowScale;
            sourcePointsLocal.push(new THREE.Vector3(0, 2.2 * s, 0)); // Tip
        } else {
            const r = 1.3 * knotScale;
            sourcePointsLocal.push(new THREE.Vector3(0, r, 0));   
            sourcePointsLocal.push(new THREE.Vector3(0, -r, 0));  
            sourcePointsLocal.push(new THREE.Vector3(0, 0, r));   
            sourcePointsLocal.push(new THREE.Vector3(0, 0, -r));  
        }
        
        while(raysGroup.children.length > 0){ 
            const obj = raysGroup.children.pop();
            if(obj.geometry) obj.geometry.dispose();
            raysGroup.remove(obj); 
        }

        sourcePointsLocal.forEach((localPt, index) => {
            const rotatedLocalPt = localPt.clone().applyEuler(objRotation);
            const objTip = new THREE.Vector3().copy(rotatedLocalPt).add(objPos);
            
            let imgTip;
            if (isParallel) {
                imgTip = new THREE.Vector3(10000 * Math.sign(f_val), 0, 0);
            } else if (Math.abs(do_val) < 0.1) {
                imgTip = objTip.clone();
            } else {
                // [FIX] Use the EXACT optical formula for the Ray Target as well
                imgTip = computeImagePos(objTip, f_val);
            }
            
            const colorIndex = (currentObjType === 'arrow') ? -1 : index;
            draw3DRays(objTip, imgTip, f_val, isReal, isParallel, colorIndex);
        });
        
        updateLayers();
    }

    function draw3DRays(objTip, imgTip, f_val, isReal, isParallel, colorIndex) {
        let rMat, vMat;
        if (colorIndex === -1) {
            rMat = rayMat; 
            vMat = virtualRayMat;
        } else {
            rMat = rayMaterials[colorIndex % rayMaterials.length];
            vMat = virtualRayMaterials[colorIndex % virtualRayMaterials.length];
        }

        const lensHit1 = new THREE.Vector3(0, objTip.y, objTip.z);
        
        // Ray 1: Parallel to Axis (from tip to lens)
        // If convex, refracts to focus (f, 0, 0)
        // If concave, refracts as if coming from focus (f, 0, 0) [f is negative]
        
        const focusPoint = new THREE.Vector3(f_val, 0, 0); 

        if (currentLensType === 'convex') {
            const pts1 = [objTip.clone(), lensHit1.clone()];
            // Direction from lens hit to focus
            const dir1 = new THREE.Vector3().subVectors(focusPoint, lensHit1).normalize();
            pts1.push(dir1.multiplyScalar(300).add(lensHit1));
            addLine(pts1, rMat); 
            
            // Virtual ray extending back to image?
            // If image is virtual, we draw dashed line from Image to Lens
            // If image is real, the solid ray connects lens to image naturally.
            // But let's draw dashed extension if needed for clarity.
            if (!isParallel && Math.abs(parseFloat(ui.dist.value)) > 0.1) {
                if (!isReal) {
                     const vPts1 = [imgTip.clone(), lensHit1.clone()];
                     addLine(vPts1, vMat, true);
                }
            }
        } else {
            // Concave
            const pts1 = [objTip.clone(), lensHit1.clone()];
            // Diverges as if from focus
            const dir1 = new THREE.Vector3().subVectors(lensHit1, focusPoint).normalize();
            pts1.push(dir1.multiplyScalar(300).add(lensHit1));
            addLine(pts1, rMat);
            
            // Virtual trace back to focus
            const vPts1 = [focusPoint.clone(), lensHit1.clone()];
            addLine(vPts1, vMat, true);
        }

        // Ray 2: Through Optical Center (Undeviated)
        const center = new THREE.Vector3(0,0,0);
        const dir2 = new THREE.Vector3().subVectors(center, objTip).normalize();
        
        // Draw solid ray through center
        const pts2 = [objTip.clone(), dir2.multiplyScalar(300).add(objTip)];
        addLine(pts2, rMat);

        // For virtual images, the ray through center is solid, but maybe we want to emphasize the backtrace?
        // Actually ray through center passes through image point naturally (since image lies on this line).
        // So no dashed line needed for Ray 2 usually.
    }

    function addLine(points, material, isDashed = false) {
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(geometry, material);
        if (isDashed) line.computeLineDistances();
        line.layers.set(0); 
        raysGroup.add(line);
    }

    function updateLayers() {
        cameraTop.layers.enable(0);
        cameraTop.layers.enable(1);
        cameraTop.layers.enable(2);
        cameraEye.layers.disableAll();
        cameraEye.layers.enable(2); 
        
        objArrow.traverse(o => { o.layers.set(1); o.layers.enable(0); });
        imgArrow.traverse(o => { o.layers.set(2); o.layers.enable(0); });
        
        const objKnot = scene.getObjectByName("ObjectKnot");
        const imgKnot = scene.getObjectByName("ImageKnot");
        if(objKnot) objKnot.traverse(o => { o.layers.set(1); o.layers.enable(0); });
        if(imgKnot) imgKnot.traverse(o => { o.layers.set(2); o.layers.enable(0); });
    }

    function render() {
        requestAnimationFrame(render);
        controls.update();

        const width = window.innerWidth;
        const height = window.innerHeight;
        const splitY = Math.floor(height * 0.45); 
        
        divider.style.top = (height - splitY) + "px";
        document.getElementById('label-eye').style.bottom = (splitY - 40) + "px";

        lensMat.stencilWrite = false;
        imageMat.stencilWrite = false;
        lensMat.depthWrite = true; 
        lensMat.side = THREE.DoubleSide;

        renderer.setViewport(0, splitY, width, height - splitY);
        renderer.setScissor(0, splitY, width, height - splitY);
        renderer.setScissorTest(true);
        renderer.setClearColor(0x111111);
        
        cameraTop.aspect = width / (height - splitY);
        cameraTop.updateProjectionMatrix();
        renderer.render(scene, cameraTop);

        renderer.setViewport(0, 0, width, splitY);
        renderer.setScissor(0, 0, width, splitY);
        renderer.setScissorTest(true);
        renderer.setClearColor(0x050505);
        renderer.clearStencil(); 
        
        const activeMesh = (currentLensType === 'convex') ? convexMesh : concaveMesh;
        activeMesh.renderOrder = 1;
        lensMat.stencilWrite = true;
        lensMat.stencilFunc = THREE.AlwaysStencilFunc; 
        lensMat.stencilRef = 1;
        lensMat.stencilZPass = THREE.ReplaceStencilOp;
        lensMat.depthWrite = false;
        lensMat.side = THREE.FrontSide;

        if(currentLensType === 'convex') concaveMesh.renderOrder = 999; 
        else convexMesh.renderOrder = 999;
        
        const activeImg = (currentObjType === 'arrow') ? imgArrow : scene.getObjectByName("ImageKnot");
        if (activeImg) {
            activeImg.renderOrder = 2; 
            activeImg.traverse(child => {
                if(child.material) {
                    child.material.stencilWrite = true;
                    child.material.stencilFunc = THREE.EqualStencilFunc; 
                    child.material.stencilRef = 1;
                }
            });
        }

        cameraEye.aspect = width / splitY;
        cameraEye.updateProjectionMatrix();
        renderer.render(scene, cameraEye);
        lensMat.depthWrite = true;
        lensMat.side = THREE.DoubleSide;
    }

    window.addEventListener('resize', () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    Object.values(ui).forEach(el => {
        if(el instanceof HTMLElement && el.tagName === 'INPUT') {
            el.addEventListener('input', updateSimulation);
        }
    });

    updateSimulation();
    render();
    </script>
</body>
</html>
